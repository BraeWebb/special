<template>
    <div class="ui two column grid segment attached left aligned">
        <div class="ui column">
            <div class="ui segment">
                <h3 class="ui header">{{student1.id}}<div class="ui label">{{student1.percent}}%</div></h3>
                <div v-for="(file, name) in code[0]">
                    <div class="ui top attached tabular menu">
                        <div class="active item">
                            {{name}}
                        </div>
                    </div>
                    <pre style="margin: 0px"><code class="java">
{{file}}
                </code></pre>
                    <br/>
                </div>
            </div>
        </div>
        <div class="ui column">
            <div class="ui segment">
                <h3 class="ui header">{{student2.id}}<div class="ui label">{{student2.percent}}%</div></h3>
              <div v-for="(file, name) in code[1]">
                  <div class="ui top attached tabular menu">
                      <div class="active item">
                          {{name}}
                      </div>
                  </div>
                  <pre style="margin: 0px"><code class="java">
{{file}}
                </code></pre>
                  <br/>
              </div>

            </div>
        </div>
    </div>
</template>


<script>

  export default {
    name: 'Case',
    props: [],
    data() {
      return {
        student1: {
          id: "s4508492",
          percent: "11"
        },
        student2: {
          id: "s4521723",
          percent: "12"
        },
        code: [{'Bus.java': 'package vehicles;\n\nimport routes.Route;\n\n/**\n * Represents a bus in the transportation network.\n */\npublic class Bus extends PublicTransport {\n    // the rego of the bus\n    private String registrationNumber;\n\n    /**\n     * Creates a new Bus object with the given id, capacity, route, and registration\n     * number.\n     *\n     * <p>Should meet the specification of {@link PublicTransport#PublicTransport(int, int, Route)},\n     * as well as extending it to include the following:\n     *\n     * <p>If the given registration number is null, an empty string should be stored\n     * instead. If the registration number contains any newline characters (\'\\n\')\n     * or carriage returns (\'\\r\'), they should be removed from the string before\n     * it is stored.\n     *\n     * @param id The identifying number of the bus.\n     * @param capacity The maximum capacity of the bus.\n     * @param route The route this bus is on.\n     * @param registrationNumber The registration number of the bus.\n     */\n    public Bus(int id, int capacity, Route route, String registrationNumber) {\n        super(id, capacity, route);\n        this.registrationNumber = registrationNumber == null ? "" : registrationNumber\n                .replace("\\n", "").replace("\\r", "");\n    }\n\n    /**\n     * Returns the registration number of this bus.\n     *\n     * @return The registration number of the bus.\n     */\n    public String getRegistrationNumber() {\n        return registrationNumber;\n    }\n\n    /**\n     * Encodes this bus as a string in the same format as specified in\n     * PublicTransport.encode(), but with an additional component at the end,\n     * namely  the bus registration number. The encoded format should be as follows:\n     * \'{type},{id},{capacity},{route},{registration}\'\n     *\n     * where {registration} is replaced by the registration number of this\n     * bus, and all of the other components are the same as defined in the method being overridden.\n     * For example:\n     *\n     * bus,1,30,1,ABC123\n     * @return This bus encoded as a string.\n     */\n    @Override\n    public String encode() {\n        return super.encode() + "," + this.registrationNumber;\n    }\n}\n', 'BusRoute.java': 'package routes;\n\n/**\n * Represents a bus route in the transportation network.\n */\npublic class BusRoute extends Route {\n\n    /**\n     * Creates a new BusRoute with the given name and number.\n     *\n     * <p>Should meet the specification of {@link Route#Route(String, int)}\n     *\n     * @param name The name of the route.\n     * @param routeNumber The route number of the route.\n     */\n    public BusRoute(String name, int routeNumber) {\n        super(name, routeNumber);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @return "bus"\n     */\n    @Override\n    public String getType() {\n        return "bus";\n    }\n}\n', 'ConcessionPassenger.java': 'package passengers;\n\nimport stops.Stop;\n\n/**\n * A passenger that pays concession fares. Concession fares require a concession id.\n */\npublic class ConcessionPassenger extends Passenger {\n    // concession id for validating concession fares\n    private int concessionId;\n\n    // whether the concession passenger has a valid concession id\n    private static final int INVALID = -1;\n\n    /**\n     * Construct a new concession fare passenger with the given name and concessionId.\n     *\n     * <p>Should meet the specification of {@link Passenger#Passenger(String, Stop)}.\n     *\n     * @param name The name of the passenger.\n     * @param destination The destination of the passenger.\n     * @param concessionId Identifying number of the passenger\'s concession card.\n     */\n    public ConcessionPassenger(String name, Stop destination, int concessionId) {\n        super(name, destination);\n        renew(concessionId);\n    }\n\n    /**\n     * Sets the concession fare to be expired, and thus invalid. {@link #isValid()}\n     * returns false.\n     */\n    public void expire() {\n        this.concessionId = INVALID;\n    }\n\n    /**\n     * Attempts to renew this concession passenger\'s fares with the given id.\n     *\n     * @param newId The ID of the renewed concession card.\n     */\n    public void renew(int newId) {\n        if (newId < 0 || Integer.toString(newId).length() < 6\n                || !Integer.toString(newId).startsWith("42")) {\n            this.concessionId = INVALID;\n        } else {\n            this.concessionId = newId;\n        }\n    }\n\n    /**\n     * Returns true if and only if the stored concessionId is valid.\n     *\n     * <p>In this transportation network, a valid concessionId begins with the digits\n     * \'42\', should be positive, and should be a minimum of six digits in length\n     * (for example, 420000 would be a valid concessionId, while 430000, -420000,\n     * or 42000 would not).\n     *\n     * @return True if concession fares have not expired (are valid), false otherwise.\n     */\n    public boolean isValid() {\n        return this.concessionId != INVALID;\n    }\n}\n', 'EmptyRouteException.java': 'package exceptions;\n\nimport routes.Route;\nimport vehicles.PublicTransport;\n\n/**\n * Exception thrown when a {@link PublicTransport} is added to a\n * {@link Route} with no {@link stops.Stop}s.\n */\npublic class EmptyRouteException extends TransportException {\n}\n', 'Ferry.java': 'package vehicles;\n\nimport routes.Route;\n\n/**\n * Represents a ferry in the transportation network.\n */\npublic class Ferry extends PublicTransport {\n    // the type of the ferry\n    private String ferryType;\n\n    /**\n     * Creates a new Ferry object with the given id, capacity, route, and type.\n     *\n     * <p>Should meet the specification of {@link PublicTransport#PublicTransport(int, int, Route)},\n     * as well as extending it to include the following:\n     *\n     * <p>If the given ferryType is null or empty, the string "CityCat" should be\n     * stored instead. If the ferry type contains any newline characters (\'\\n\')\n     * or carriage returns (\'\\r\'), they should be removed from the string before\n     * it is stored.\n     *\n     * @param id        The identifying number of the ferry.\n     * @param capacity  The maximum capacity of the ferry.\n     * @param route     The route this ferry is on.\n     * @param ferryType The type of the ferry (e.g. CityCat).\n     */\n    public Ferry(int id, int capacity, Route route, String ferryType) {\n        super(id, capacity, route);\n        this.ferryType = ferryType == null || ferryType.isEmpty() ? "CityCat" :\n                ferryType.replace("\\n", "").replace("\\r", "");\n    }\n\n    /**\n     * Returns the type of this ferry.\n     *\n     * @return The type of the ferry.\n     */\n    public String getFerryType() {\n        return ferryType;\n    }\n\n    /**\n     * Encodes this ferry as a string in the same format as specified in\n     * PublicTransport.encode(), but with an additional component at the\n     * end, namely the ferry type. The encoded format should be as follows:\n     * \'{type},{id},{capacity},{route},{ferryType}\'\n     *\n     * where {ferryType} is replaced by the type of this ferry, and all of\n     * the other components are the same as defined in the method being overridden.\n     * For example:\n     *\n     * ferry,2,50,2,CityCat\n     * @return This ferry encoded as a string.\n     */\n    @Override\n    public String encode() {\n        return super.encode() + "," + this.ferryType;\n    }\n}\n', 'FerryRoute.java': 'package routes;\n\n/**\n * Represents a ferry route in the transportation network.\n */\npublic class FerryRoute extends Route {\n\n    /**\n     * Creates a new FerryRoute with the given name and number.\n     *\n     * <p>Should meet the specification of {@link Route#Route(String, int)}\n     *\n     * @param name The name of the route.\n     * @param routeNumber The route number of the route.\n     */\n    public FerryRoute(String name, int routeNumber) {\n        super(name, routeNumber);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @return "ferry"\n     */\n    @Override\n    public String getType() {\n        return "ferry";\n    }\n}\n', 'IncompatibleTypeException.java': 'package exceptions;\n\nimport routes.Route;\nimport vehicles.PublicTransport;\n\n/**\n * Exception thrown when a subclass of {@link PublicTransport} is\n * added to a {@link Route} for a different type of transport.\n *\n * i.e. Train added to BusRoute\n */\npublic class IncompatibleTypeException extends TransportException {\n}\n', 'Network.java': 'package network;\n\nimport exceptions.TransportFormatException;\nimport routes.Route;\nimport stops.Stop;\nimport vehicles.PublicTransport;\n\n\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Network {\n\n\n    private List<Stop> stopList;\n    private List<Route> routeList;\n    private List<PublicTransport> transportList;\n\n    /**\n     * Creates a new empty Network with no stops, vehicles, or routes.\n     */\n    public Network() {\n        stopList = new ArrayList<>();\n        routeList = new ArrayList<>();\n        transportList = new ArrayList<>();\n    }\n\n    /**\n     * Creates a new Network from information contained in the file\n     * indicated by the given filename. The file should be in the following format:\n     * {number_of_stops}\n     * {stop0:x0:y0}\n     * ...\n     * {stopN:xN:yN}\n     * {number_of_routes}\n     * {type0,name0,number0:stop0|stop1|...|stopM}\n     * ...\n     * {typeN,nameN,numberN:stop0|stop1|...|stopM}\n     * {number_of_vehicles}\n     * {type0,id0,capacity0,routeNumber,extra}\n     * ...\n     * {typeN,idN,capacityN,routeNumber,extra}\n     * where {number_of_stops}, {number_of_routes}, and {number_of_vehicles}\n     * are the number of stops, routes, and vehicles (respectively) in the\n     * network, and where {stop0,x0,y0} is the encode() representation of a\n     * Stop, {type0,name0,number0:stop0|stop1|...|stopM} is the encode()\n     * representation of a Route, and {typeN,idN,capacityN,routeNumber,extra\n     * } is the encode() representation of a PublicTransport.\n     *\n     * Whilst parsing, if spaces (i.e. \' \') are encountered before or after\n     * integers, (i.e. {number_of_stops}, {number_of_routes}, or {\n     * number_of_vehicles}), the spaces should simply be trimmed (for\n     * example, using something like String.trim()).\n     *\n     * For example:\n     * 4\n     * stop0:0:1\n     * stop1:-1:0\n     * stop2:4:2\n     * stop3:2:-8\n     * 2\n     * train,red,1:stop0|stop2|stop1\n     * bus,blue,2:stop1|stop3|stop0\n     * 3\n     * train,123,30,1,2\n     * train,42,60,1,3\n     * bus,412,20,2,ABC123\n     * The Network object created should have the stops, routes, and\n     * vehicles contained in the given file.\n     * @param filename The name of the file to load the network from.\n     * @throws IOException If any IO exceptions occur whilst trying to read\n     * from the file, or if the filename is null.\n     * @throws TransportFormatException\n     * If any of the lines representing stops, routes, or vehicles are\n     * incorrectly formatted according to their respective decode methods\n     * (i.e. if their decode method throws an exception).\n     * If any of the integers are incorrectly formatted (i.e. cannot be pars ed).\n     * If the {number_of_stops} does not match the actual number of lines\n     * representing stops present. This also applies to {number_of_routes}\n     * and {number_of_vehicles}. An error should also be thrown if any of\n     * these integers are negative.\n     * If there are any extra lines present in the file (the file may end\n     * with a single newline character, but there may not be multiple blank\n     * lines at the end of the file).\n     * If any other formatting issues are encountered whilst parsing the\n     * file (sample valid and invalid network files will be provided to help\n     * identify some potential issues).\n     * Method Detail\n     */\n    public Network(String filename) throws IOException,\n            TransportFormatException {\n        if (filename == null) {\n            throw new IOException();\n        }\n        stopList = new ArrayList<>();\n        routeList = new ArrayList<>();\n        transportList = new ArrayList<>();\n        try {\n            BufferedReader bf = new BufferedReader(new FileReader(filename));\n            String line = bf.readLine().trim();\n            for (int i = 0; i < Integer.parseInt(line); i++) {\n                stopList.add(Stop.decode(bf.readLine()));\n            }\n            line = bf.readLine().trim();\n            for (int i = 0; i < Integer.parseInt(line); i++) {\n                routeList.add(Route.decode(bf.readLine(), stopList));\n            }\n            line = bf.readLine().trim();\n            for (int i = 0; i < Integer.parseInt(line); i++) {\n                transportList.add(PublicTransport.decode(bf.readLine(),\n                        routeList));\n            }\n            if (bf.readLine() == null) {\n                bf.close();\n            } else {\n                throw new TransportFormatException();\n            }\n        } catch (IOException e) {\n            throw new IOException();\n\n\n        } catch (NumberFormatException e) {\n            throw new TransportFormatException();\n        }\n    }\n\n    /**\n     * Adds the given route to the network.\n     * If the given route is null, it should not be added to the network.\n     * @param route The route to add to the network.\n     */\n    public void addRoute(Route route) {\n        if (route != null) {\n            routeList.add(route);\n        }\n    }\n\n    /**\n     * Adds the given stop to the transportation network.\n     * If the given stop is null, it should not be added to the network.\n     * @param stop The stop to add to the network.\n     */\n    public void addStop(Stop stop) {\n        if (stop != null) {\n            stopList.add(stop);\n        }\n    }\n\n    /**\n     * Adds multiple stops to the transport network.\n     * If any of the stops in the given list are null, none of them should be added (i.e. either all of the stops are added, or none are).\n     * @param stops The stops to add to the network.\n     */\n    public void addStops(List<Stop> stops) {\n        if (stops.contains(null)) {\n            return;\n        } else {\n            for (Stop stop : stops) {\n\n\n                stopList.add(stop);\n            }\n        }\n    }\n\n    /**\n     * Adds the given vehicle to the network.\n     * If the given vehicle is null, it should not be added to the network.\n     * @param vehicle The vehicle to add to the network.\n     */\n    public void addVehicle(PublicTransport vehicle) {\n        if (vehicle != null) {\n            transportList.add(vehicle);\n        }\n    }\n\n    /**\n     * Gets all the routes in this network.\n     * Modifying the returned list should not result in changes to the internal state of the class.\n     * @return All the routes in the network.\n     */\n    public List<Route> getRoutes() {\n        return new ArrayList<>(routeList);\n    }\n\n    /**\n     * Gets all of the stops in this network.\n     * Modifying the returned list should not result in changes to the internal state of the class.\n     * @return All the stops in the network.\n     */\n    public List<Stop> getStops() {\n        return new ArrayList<>(stopList);\n    }\n\n    /**\n     * Gets all the vehicles in this transportation network.\n     * Modifying the returned list should not result in changes to the internal state of the class.\n     * @return All the vehicles in the transportation network.\n     */\n    public List<PublicTransport> getVehicles() {\n        return new ArrayList<>(transportList);\n    }\n\n    /**\n     * Saves this network to the file indicated by the given filename.\n     * The file should be written with the same format as described in the\n     * Network(String) constructor.\n     *\n     * The stops should be written to the file in the same order in which\n     * they were added to the network. This also applies to the routes and the vehicles.\n     *\n     * If the given filename is null, the method should do nothing.\n     * @param filename The name of the file to save the network to.\n     * @throws IOException  If there are any IO errors whilst writing to the file.\n     */\n    public void save(String filename) throws IOException {\n        if (filename == null) {\n            return;\n        }\n        try {\n            StringBuilder sb = new StringBuilder();\n            sb.append(getStops().size() + "\\n");\n            for (int i = 0; i < getStops().size(); i++) {\n                sb.append(getStops().get(i).encode() + "\\n");\n            }\n            sb.append(getRoutes().size() + "\\n");\n            for (int i = 0; i < getRoutes().size(); i++) {\n                sb.append(getRoutes().get(i).encode() + "\\n");\n            }\n            sb.append(getVehicles().size() + "\\n");\n            for (int i = 0; i < getVehicles().size(); i++) {\n                sb.append(getVehicles().get(i).encode() + "\\n");\n            }\n            FileWriter fw = new FileWriter(filename);\n            fw.write(sb.toString());\n            fw.close();\n        } catch (IOException ioe) {\n            throw new IOException();\n        }\n    }\n\n}\n', 'NetworkTest.java': 'package network;\n\nimport exceptions.TransportFormatException;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport routes.BusRoute;\nimport routes.Route;\nimport routes.TrainRoute;\nimport stops.Stop;\nimport vehicles.Bus;\nimport vehicles.PublicTransport;\nimport vehicles.Train;\n\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.Assert.*;\n\npublic class NetworkTest {\n    private PublicTransport bus1;\n    private Stop stop0;\n    private Stop stop1;\n    private Stop stop2;\n    private Stop stop3;\n    private Route trainRoute;\n    private Route busRoute;\n    private PublicTransport train1;\n    private PublicTransport train2;\n    private List<Stop> validStops;\n    private List<Stop> invalidStops;\n\n    @Before\n    public void setUp() {\n        stop0 = new Stop("stop0", 0, 1);\n        stop1 = new Stop("stop1", -1, 0);\n        stop2 = new Stop("stop2", 4, 2);\n        stop3 = new Stop("stop3", 2, -8);\n        trainRoute = new TrainRoute("red", 1);\n\n\n        busRoute = new BusRoute("blue", 2);\n        trainRoute.addStop(stop0);\n        trainRoute.addStop(stop2);\n        trainRoute.addStop(stop1);\n        busRoute.addStop(stop1);\n        busRoute.addStop(stop3);\n        busRoute.addStop(stop0);\n        train1 = new Train(123, 30, trainRoute, 2);\n        train2 = new Train(42, 60, trainRoute, 3);\n        bus1 = new Bus(412, 20, busRoute, "ABC123");\n        validStops = new ArrayList<>();\n        validStops.add(stop0);\n        validStops.add(stop1);\n        validStops.add(stop2);\n        validStops.add(stop3);\n        invalidStops = new ArrayList<>();\n        invalidStops.add(stop0);\n        invalidStops.add(null);\n        invalidStops.add(stop1);\n    }\n\n    @After\n    public void tearDown() {\n        invalidStops = new ArrayList<>();\n        validStops = new ArrayList<>();\n    }\n\n    /**\n     * Test construct without filename and no exception.\n     */\n    @Test\n\n\n    public void testConstructor1Test() {\n        Network network = new Network();\n        assertTrue(network.getStops().isEmpty());\n        assertTrue(network.getRoutes().isEmpty());\n        assertTrue(network.getVehicles().isEmpty());\n    }\n\n    /**\n     * Test construct with filename and no exception.\n     */\n    @Test\n    public void testConstructor2Test1() throws IOException,\n            TransportFormatException {\n        Network network = new Network("networks/validFromSpec.txt");\n        assertTrue(network.getStops().size() == 4);\n        assertTrue(network.getStops().contains(stop0));\n        assertTrue(network.getRoutes().size() == 2);\n        assertTrue(network.getRoutes().contains(trainRoute));\n        assertTrue(network.getVehicles().size() == 3);\n        Network network1 = new Network("networks/validEmptyRoute.txt");\n        assertEquals(4, network1.getStops().size());\n    }\n\n    /**\n     * Test when IO exception occurs, file name does not exist\n     */\n    @Test(expected = IOException.class)\n    public void testConstructor2Test2() throws IOException,\n            TransportFormatException {\n        Network network = new Network("fileNameDoesNotExist");\n\n    }\n\n    /**\n     * Test IO exception occurs when the file is null\n     */\n    @Test(expected = IOException.class)\n    public void testConstructor2Test3() throws IOException,\n            TransportFormatException {\n        Network network = new Network(null);\n\n    }\n\n    /**\n     * Test when route format is not correct that route with empty stop\n     * names, throw TransportFormatException.\n     */\n    @Test(expected = TransportFormatException.class)\n    public void testConstructor2Test4() throws TransportFormatException,\n            IOException {\n        new Network("networks/invalidRouteEmptyStopNames.txt");\n    }\n\n    /**\n     * Test when integer is incorrect format, throw TransportFormatException.\n     *\n     * @throws TransportFormatException\n     */\n    @Test(expected = TransportFormatException.class)\n    public void testConstructor2Test5() throws TransportFormatException,\n            IOException {\n        Network network = new Network("networks/invalidTransportIntegers" +\n                ".txt");\n    }\n\n    /**\n     * Test when stop count dose not match the number of stops, throw\n     * TransportFormatException.\n     *\n     * @throws TransportFormatException\n     */\n    @Test(expected = TransportFormatException.class)\n    public void testConstructor2Test6() throws TransportFormatException,\n            IOException {\n        Network network = new Network("networks/invalidStopCount.txt");\n    }\n\n    /**\n     * Test if there is an extra line at end of file, throw\n     * TransportFormatException.\n     *\n     * @throws TransportFormatException\n     */\n    @Test(expected = TransportFormatException.class)\n    public void testConstructor2Test7() throws TransportFormatException,\n            IOException {\n        new Network("networks/invalidStopCount.txt");\n    }\n\n    /**\n     * Test when adding route is null, it should do nothing.\n     */\n    @Test\n    public void testAddRoute1() {\n        Network network = new Network();\n        network.addRoute(null);\n        assertTrue(network.getRoutes().isEmpty());\n    }\n\n    /**\n     * Test when adding route works, it should be added into routesList of\n     * network\n     */\n    @Test\n    public void testAddRoute2() {\n        Network network = new Network();\n        assertTrue(network.getRoutes().size() == 0);\n        network.addRoute(trainRoute);\n\n\n        assertTrue(network.getRoutes().contains(trainRoute));\n        assertTrue(network.getRoutes().size() == 1);\n    }\n\n    /**\n     * Test when adding stop is null, it should do nothing.\n     */\n    @Test\n    public void testAddStop1() {\n        Network network = new Network();\n        network.addStop(null);\n        assertTrue(network.getStops().isEmpty());\n\n    }\n\n    /**\n     * Test when adding stop works, it should be added into stopsList of\n     * network\n     */\n    @Test\n    public void testAddStop2() {\n        Network network = new Network();\n\n\n        network.addStop(stop0);\n        assertTrue(network.getStops().get(0).equals(stop0));\n    }\n\n    /**\n     * Test when adding a list with null element, none of them should be\n     * added into network\n     */\n    @Test\n    public void testAddStops1() {\n        // Create a stop list with null element\n        Network network = new Network();\n        network.addStops(invalidStops);\n        assertTrue(network.getStops().isEmpty());\n    }\n\n    /**\n     * Test when adding stops list works, all of them should be added into\n     * the network\n     */\n    @Test\n    public void testAddStops2() {\n        Network network = new Network();\n        network.addStops(validStops);\n        assertTrue(network.getStops().equals(validStops));\n    }\n\n    /**\n     * Test when adding vehicle is null, it should do nothing.\n     */\n    @Test\n    public void testAddVehicle1() {\n        Network network = new Network();\n        network.addVehicle(null);\n        assertTrue(network.getVehicles().isEmpty());\n    }\n\n    /**\n     * Test addVehicle works, and it should be added into vehicleList of\n     * network.\n     */\n    @Test\n    public void testAddVehicle2() {\n        Network network = new Network();\n        network.addVehicle(bus1);\n        assertTrue(network.getVehicles().size() == 1);\n    }\n\n    /**\n     * Test when getRoutes works, and the returning list should contain all\n     * routes that in this network.\n     */\n    @Test\n    public void testGetRoutes1() throws IOException,\n            TransportFormatException {\n        List<Route> routeList = new ArrayList<>();\n        routeList.add(trainRoute);\n        routeList.add(busRoute);\n        Network network = new Network("networks/validFromSpec.txt");\n        assertEquals(routeList, network.getRoutes());\n    }\n\n    /**\n     * Test when modifying the returned list and it will not change the\n     * internal state of the class.\n     */\n    @Test\n    public void testGetRoutes2() throws IOException,\n            TransportFormatException {\n        List<Route> routeList = new ArrayList<>();\n        routeList.add(trainRoute);\n        routeList.add(busRoute);\n        Network network = new Network("networks/validFromSpec.txt");\n        network.getRoutes().clear();\n        assertEquals(routeList, network.getRoutes());\n    }\n\n    /**\n     * Test when getRoutes works, and the returning list should contain all\n     * routes that in this network.\n     */\n    @Test\n    public void testGetStops1() throws IOException,\n            TransportFormatException {\n        Network network = new Network("networks/validFromSpec.txt");\n        assertEquals(validStops, network.getStops());\n    }\n\n    /**\n     * Test when modifying the returned list and it will not change the\n     * internal state of the class.\n     */\n    @Test\n    public void testGetStops2() throws IOException, TransportFormatException {\n        Network network = new Network("networks/validFromSpec.txt");\n        network.getStops().clear();\n        assertEquals(validStops, network.getStops());\n    }\n\n    /**\n     * Test when getRoutes works, and the returning list should contain all\n     * routes that in this network.\n     */\n    @Test\n    public void testGetVehicles1() throws IOException,\n            TransportFormatException {\n        Network network = new Network("networks/validFromSpec.txt");\n        assertEquals(train1.toString(), network.getVehicles().get(0)\n                .toString());\n        assertEquals(train2.toString(), network.getVehicles().get(1)\n                .toString());\n        assertEquals(bus1.toString(), network.getVehicles().get(2).toString());\n        assertEquals(3, network.getVehicles().size());\n    }\n\n    /**\n     * Test when modifying the returned list and it will not change the\n     * internal state of the class.\n     */\n    @Test\n    public void testGetVehicles2() throws IOException,\n            TransportFormatException {\n        Network network = new Network("networks/validFromSpec.txt");\n        network.getVehicles().clear();\n        assertEquals(train1.toString(), network.getVehicles().get(0)\n                .toString());\n        assertEquals(train2.toString(), network.getVehicles().get(1)\n                .toString());\n        assertEquals(bus1.toString(), network.getVehicles().get(2).toString\n                ());\n        assertEquals(3, network.getVehicles().size());\n    }\n\n    /**\n     * Test save(), construct network first, using Network(String filename);\n     * then use network.save() to save it.\n     * then compare the saved file with original\n     */\n    @Test\n    public void testSave2() {\n        try {\n            Network network = new Network("networks/validFromSpec.txt");\n            network.save("saved.txt");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (TransportFormatException e) {\n            e.printStackTrace();\n        }\n        try {\n            BufferedReader bf1 = new BufferedReader(new FileReader\n                    ("networks/validFromSpec.txt"));\n            String file1 = "";\n            String line1;\n            while ((line1 = bf1.readLine()) != null) {\n                file1 += line1;\n                file1 += "\\n";\n            }\n            BufferedReader bf = new BufferedReader(new FileReader\n                    ("saved.txt"));\n            String file = "";\n            String line;\n            while ((line = bf.readLine()) != null) {\n                file += line;\n                file += "\\n";\n            }\n            assertEquals(file1, file);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Test when file name is null, it should do nothing, and does not throw\n     * any exception.\n     */\n    @Test\n    public void testSave1() {\n        Network network = new Network();\n        try {\n            network.save(null);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}', 'NoNameException.java': 'package exceptions;\n\n/**\n * Exception thrown when a {@link stops.Stop} is created with a null or empty name.\n */\npublic class NoNameException extends RuntimeException {\n}\n', 'OverCapacityException.java': 'package exceptions;\n\nimport passengers.Passenger;\nimport vehicles.PublicTransport;\n\n/**\n * Exception thrown when a {@link Passenger} is added to a\n * {@link PublicTransport} which has reached capacity.\n *\n * (i.e. {@link PublicTransport#passengerCount()} >= {@link PublicTransport#getCapacity()})\n */\npublic class OverCapacityException extends TransportException {\n}\n', 'Passenger.java': 'package passengers;\n\nimport stops.Stop;\n\n/**\n * A base passenger in the transport network.\n */\npublic class Passenger {\n    // name of the passenger\n    private String name;\n\n    // intended destination of the passenger\n    private Stop destination;\n\n    /**\n     * Construct a new base passenger with the given name, and without a destination.\n     *\n     * <p>If the given name is null, an empty string should be stored instead.\n     *\n     * <p>If the given name contains any newline characters (\'\\n\') or carriage returns\n     * (\'\\r\'), they should be removed from the string before it is stored.\n     *\n     * @param name The name of the passenger.\n     */\n    public Passenger(String name) {\n        this.name = name == null ? "" : name.replace("\\n","")\n                .replace("\\r", "");\n        this.destination = null;\n    }\n\n    /**\n     * Construct a new base passenger with the given name and destination.\n     *\n     * <p> Should meet the specification of {@link Passenger#Passenger(String)},\n     * as well as storing the given destination stop.\n     *\n     * @param name The name of the passenger.\n     * @param destination The destination of the passenger.\n     */\n    public Passenger(String name, Stop destination) {\n        this(name);\n        this.destination = destination;\n    }\n\n    /**\n     * Returns the name of the passenger.\n     *\n     * @return The name of the passenger.\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Sets the destination of the passenger.\n     *\n     * <p>A value of null for the given stop simply indicates that the passenger\n     * has no destination.\n     *\n     * @param destination The intended destination of the passenger, or null if\n     *                    the passenger has no destination.\n     */\n    public void setDestination(Stop destination) {\n        this.destination = destination;\n    }\n\n    /**\n     * Gets the destination of the passenger.\n     *\n     * @return The intended destination of the passenger, or null if the passenger\n     * has no destination.\n     */\n    public Stop getDestination() {\n        return destination;\n    }\n\n    /**\n     * Creates a string representation of the passenger in the format:\n     *\n     * <p>\'Passenger named {name}\'\n     *\n     * <p>without surrounding quotes and with {name} replaced by the name of the\n     * passenger instance. For example:\n     *\n     * <p>Passenger named Agatha\n     *\n     * <p>If the passenger\'s name is empty, the method should instead return the\n     * following:\n     *\n     * <p>Anonymous passenger\n     *\n     * @return A string representation of the passenger.\n     */\n    @Override\n    public String toString() {\n        return name.isEmpty() ? "Anonymous passenger" : "Passenger named " +\n                name;\n    }\n}\n', 'PublicTransport.java': 'package vehicles;\n\nimport exceptions.EmptyRouteException;\nimport exceptions.IncompatibleTypeException;\nimport exceptions.OverCapacityException;\nimport exceptions.TransportFormatException;\nimport passengers.Passenger;\nimport routes.Route;\nimport stops.Stop;\nimport utilities.Writeable;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * A base public transport vehicle in the transportation network.\n */\npublic abstract class PublicTransport implements Writeable {\n    // the passengers currently on board the vehicle\n    private List<Passenger> passengers;\n\n    // the place the vehicle is currently stopped\n    private Stop currentLocation;\n\n    // the maximum passengers allowed on board the vehicle\n    private int capacity;\n\n    // the vehicle\'s identifier\n    private int id;\n\n    // the route the vehicle follows\n    private Route route;\n\n    /**\n     * Creates a new public transport vehicle with the given id, capacity, and\n     * route.\n     *\n     * <p>The vehicle should initially have no passengers on board, and should be placed\n     * at the beginning of the given route (given by {@link Route#getStartStop()}).\n     * If the route is empty, the current location should be stored as null.\n     *\n     * <p> If the given capacity is negative, 0 should be stored as the capacity\n     * instead (meaning no passengers will be allowed on board this vehicle).\n     *\n     * @param id       The identifying number of the vehicle.\n     * @param capacity The maximum number of passengers allowed on board.\n     * @param route    The route the vehicle follows. Note that the given route should\n     *                 never be null (@require route != null), and thus will not be\n     *                 tested with a null value.\n     */\n    public PublicTransport(int id, int capacity, Route route) {\n        this.passengers = new ArrayList<>();\n        this.capacity = capacity < 0 ? 0 : capacity;\n        this.id = id;\n        this.route = route;\n        try {\n            this.currentLocation = route.getStartStop();\n        } catch (EmptyRouteException e) {\n            this.currentLocation = null;\n        }\n    }\n\n    /**\n     * Returns the route this vehicle is on.\n     *\n     * @return The route this vehicle is on.\n     */\n    public Route getRoute() {\n        return route;\n    }\n\n    /**\n     * Returns the id of this vehicle.\n     *\n     * @return The id of this vehicle.\n     */\n    public int getId() {\n        return id;\n    }\n\n    /**\n     * Returns the current location of this vehicle.\n     *\n     * @return The stop this vehicle is currently located at, or null if it is not\n     * currently located at a stop.\n     */\n    public Stop getCurrentStop() {\n        return currentLocation;\n    }\n\n    /**\n     * Returns the number of passengers currently on board this vehicle.\n     *\n     * @return The number of passengers in the vehicle.\n     */\n    public int passengerCount() {\n        return passengers.size();\n    }\n\n    /**\n     * Returns the maximum number of passengers allowed on this vehicle.\n     *\n     * @return The maximum capacity of the vehicle.\n     */\n    public int getCapacity() {\n        return capacity;\n    }\n\n    /**\n     * Returns the type of this vehicle, as determined by the type of the route it\n     * is on (i.e. The type returned by {@link Route#getType()}).\n     *\n     * @return The type of this vehicle.\n     */\n    public String getType() {\n        return route.getType();\n    }\n\n    /**\n     * Returns the passengers currently on-board this vehicle.\n     *\n     * <p>No specific order is required for the passenger objects in the returned\n     * list.\n     *\n     * <p>Modifying the returned list should not result in changes to the internal\n     * state of the class.\n     *\n     * @return The passengers currently on the public transport vehicle.\n     */\n    public List<Passenger> getPassengers() {\n        return new ArrayList<>(passengers);\n    }\n\n    /**\n     * Adds the given passenger to this vehicle.\n     *\n     * <p>If the passenger is null, the method should return without adding it\n     * to the vehicle.\n     *\n     * <p>If the vehicle is already at (or over) capacity, an exception should\n     * be thrown and the passenger should not be added to the vehicle.\n     *\n     * @param passenger The passenger boarding the vehicle.\n     * @throws OverCapacityException If the vehicle is already at (or over) capacity.\n     */\n    public void addPassenger(Passenger passenger) throws OverCapacityException {\n        if (passenger == null) {\n            return;\n        }\n\n        if (passengers.size() >= capacity) {\n            throw new OverCapacityException();\n        }\n        passengers.add(passenger);\n    }\n\n    /**\n     * Removes the given passenger from the vehicle.\n     *\n     * <p>If the passenger is null, or is not on board the vehicle, the method should\n     * return false, and should not have any effect on the passengers currently\n     * on the vehicle.\n     *\n     * @param passenger The passenger disembarking the vehicle.\n     * @return True if the passenger was successfully removed, false otherwise (including\n     * the case where the given passenger was not on board the vehicle to\n     * begin with).\n     */\n    public boolean removePassenger(Passenger passenger) {\n        return passengers.remove(passenger);\n    }\n\n    /**\n     * Empties the vehicle of all its current passengers, and returns all the passengers\n     * who were removed.\n     *\n     * <p>No specific order is required for the passenger objects in the returned\n     * list.\n     *\n     * <p>If there are no passengers currently on the vehicle, the method just\n     * returns an empty list.\n     *\n     * <p>Modifying the returned list should not result in changes to the internal\n     * state of the class.\n     *\n     * @return The passengers who used to be on the vehicle.\n     */\n    public List<Passenger> unload() {\n        List<Passenger> leaving = passengers;\n        passengers = new ArrayList<>();\n        return leaving;\n    }\n\n    /**\n     * Updates the current location of the vehicle to be the given stop.\n     *\n     * <p>If the given stop is null, or is not on this public transport\'s route\n     * the current location should remain unchanged.\n     *\n     * @param stop The stop the vehicle has travelled to.\n     */\n    public void travelTo(Stop stop) {\n        if (!route.getStopsOnRoute().contains(stop)) {\n            return;\n        }\n\n\n\n        currentLocation = stop == null ? currentLocation : stop;\n    }\n\n    /**\n     * Creates a string representation of a public transport vehicle in the format:\n     *\n     * <p>\'{type} number {id} ({capacity}) on route {route}\'\n     *\n     * <p>without the surrounding quotes, and where {type} is replaced by the type of\n     * the vehicle, {id} is replaced by the id of the vehicle, {capacity} is replaced\n     * by the maximum capacity of the vehicle, and {route} is replaced by the route\n     * number of the route the vehicle is on. For example:\n     *\n     * <p>bus number 1 (30) on route 1\n     *\n     * @return A string representation of the vehicle.\n     */\n    @Override\n    public String toString() {\n        return getType() + " number " + id + " (" + capacity + ") on route "\n                + route.getRouteNumber();\n    }\n\n    /**\n     * Encodes this vehicle as a string in the format:\n     * <p>\'{type},{id},{capacity},{route}\'\n     *\n     * <p>without the surrounding quotes, and where {type} is replaced by\n     * the type of the vehicle, {id} is replaced by the id of the vehicle, {\n     * capacity} is replaced by the maximum capacity of the vehicle, and {\n     * route} is replaced by the route number of the route the vehicle is on\n     * . For example:\n     *\n     * <p>bus,1,30,1\n     *\n     * @return This vehicle encoded as a string.\n     */\n    @Override\n    public String encode() {\n        return getType() + "," + id + "," + capacity + "," + route\n                .getRouteNumber();\n    }\n\n    /**\n     * Creates a new public transport object based on the given string represen\n     * tation.\n     * The format of the given string should match that returned by the encode(\n     * ) method, with one modification:\n     * <p>\n     * \'{type},{id},{capacity},{route},{extra}\'\n     * <p>\n     * where all parts of the string are as defined in encode(), except for {ex\n     * tra}, which should be replaced with a different part depending on the\n     * type of vehicle being decoded (as given by {type}).\n     * <p>\n     * If {type} is bus, then {extra} should be the registration number of the bus.\n     * If {type} is train, then {extra} should be the carriage count of the train.\n     * If {type} is ferry, then {extra} should be the type of the ferry.\n     * <p>\n     * The decoded vehicle should be added to the Route indicated by {route}\n     * using the Route.addTransport(PublicTransport) method. If there are\n     * multiple routes in the existingRoutes list which have the same\n     * number, then the first route in the list with a matching number should be used.\n     * <p>\n     * Whilst parsing, if spaces (i.e. \' \') are encountered before or after\n     * integers, (e.g. {id}), the spaces should simply be trimmed (for\n     * example, using something like String.trim()). If spaces are\n     * encountered before or after strings (e.g. {type}), the spaces should\n     * be considered part of the string and not handled differently from any\n     * other character.\n     *\n     * @param transportString  The string to decode\n     * @param existingRoutes The routes which currently exist in the transport network\n     * @return The decoded public transport object (a Bus, Train, or Ferry, depending on the type given in the string).\n     * @throws TransportFormatException If the given string or\n     * existingRoutes list is null, or the string is otherwise incorrectly\n     * formatted (according to the encode() representation). This includes, but is not limited to:\n     * A transport type that is not one of "bus", "train", or "ferry".\n     * One of the id, capacity, or route number is not an integer value.\n     * The route number given in the string does not match one of the given\n     * existingRoutes.\n     * The type of the route referenced in the given string does not match\n     * the type given in the transportString (e.g. a Bus referencing a TrainRoute).\n     * A vehicle of type train whose {extra} part (i.e. carriage count) is\n     * not an integer value.\n     * An error (i.e. EmptyRouteException or IncompatibleTypeException is\n     * encountered whilst adding the vehicle to its route\n     * Any extra delimiters (,) being encountered whilst parsing.\n     * Any of the parts of the string being missing.\n     */\n    public static PublicTransport decode(String transportString, List<Route>\n            existingRoutes) throws TransportFormatException {\n        int count = 0;\n        for (int i = 0; i < transportString.length(); i++) {\n            if (transportString.charAt(i) == \',\') {\n                count++;\n            }\n        }\n        if (count != 4) {\n            throw new TransportFormatException();\n        }\n        String[] transportInfo = transportString.split(",");\n        PublicTransport transport;\n        Route routeInfo = null;\n        try {\n            for (Route route : existingRoutes) {\n                if (route.getRouteNumber() == Integer.parseInt\n                        (transportInfo[3])) {\n                    routeInfo = route;\n                }\n            }\n            if (routeInfo == null || !routeInfo.getType().equals\n                    (transportInfo[0]))\n                throw new TransportFormatException();\n            String id = transportInfo[1].trim();\n            String capacity = transportInfo[2].trim();\n            switch (transportInfo[0]) {\n                case "bus":\n                    transport = new Bus(Integer.parseInt(id), Integer\n                            .parseInt(capacity), routeInfo, transportInfo[4]);\n                    break;\n                case "ferry":\n                    transport = new Ferry(Integer.parseInt(id), Integer\n                            .parseInt(capacity), routeInfo, transportInfo[4]);\n                    break;\n                case "train":\n                    transport = new Train(Integer.parseInt(id),\n                            Integer.parseInt(capacity), routeInfo,\n                            Integer.parseInt(transportInfo[4].trim()));\n                    break;\n                default:\n                    throw new TransportFormatException();\n            }\n        } catch (NumberFormatException e) {\n            throw new TransportFormatException();\n        }\n        try {\n            routeInfo.addTransport(transport);\n        } catch (EmptyRouteException e) {\n\n\n            throw new TransportFormatException();\n        } catch (IncompatibleTypeException e) {\n            throw new TransportFormatException();\n        }\n        return transport;\n    }\n\n\n}\n', 'PublicTransportTest.java': 'package vehicles;\n\nimport exceptions.EmptyRouteException;\nimport exceptions.TransportFormatException;\nimport routes.BusRoute;\nimport routes.Route;\nimport stops.Stop;\n\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n\npublic class PublicTransportTest {\n\n    @org.junit.Test\n    public void decode() throws TransportFormatException {\n//        String str = "train,1,30,169,1234";\n//        Route route = new BusRoute("uqbus", 169);\n//        List<Route> list = new ArrayList<>();\n//        list.add(route);\n//        try {\n//            PublicTransport publicTransport = PublicTransport.decode(str,\n//                    list);\n//            System.out.println(publicTransport.getType());\n//            System.out.println(publicTransport.encode());\n//        } catch (TransportFormatException e) {\n//            e.printStackTrace();\n//        }\n        String routeString = "bus,red,1:UQ Lakes";\n\n\n        Stop stop = new Stop("UQ Lakes", 1, 0);\n        Stop stop3 = new Stop("UQ Lakes", 1, 2);\n        Stop stop1 = new Stop("City", 1, 1);\n        Stop stop2 = new Stop("Valley", 1, 4);\n        List<Stop> stops = new ArrayList<Stop>();\n        stops.add(stop);\n        stops.add(stop1);\n        stops.add(stop2);\n        stops.add(stop3);\n        Route route = Route.decode(routeString, stops);\n        System.out.println(route.getRouteNumber());\n        try {\n            System.out.println(route.getStartStop().getY());\n        } catch (EmptyRouteException e) {\n            e.printStackTrace();\n        }\n    }\n}', 'Route.java': 'package routes;\n\nimport exceptions.EmptyRouteException;\nimport exceptions.IncompatibleTypeException;\nimport exceptions.TransportFormatException;\nimport stops.Stop;\nimport utilities.Writeable;\nimport vehicles.PublicTransport;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Represents a route in the transportation network.\n *\n * <p>A route is essentially a collection of stops which public transport vehicles\n * can follow.\n */\npublic abstract class Route implements Writeable {\n    // the name of the route\n    private String name;\n\n    // the number of the route\n    private int routeNumber;\n\n    // tracks where vehicles are currently located on the route\n    private List<PublicTransport> vehicles;\n\n    // the stops which make up the route\n    private List<Stop> route;\n\n    /**\n     * Creates a new Route with the given name and number.\n     *\n     * <p>The route should initially have no stops or vehicles on it.\n     *\n     * <p>If the given name contains any newline characters (\'\\n\') or carriage returns\n     * (\'\\r\'), they should be removed from the string before it is stored.\n     *\n     * <p>If the given name is null, an empty string should be stored in its place.\n     *\n     * @param name        The name of the route.\n     * @param routeNumber The route number of the route.\n     */\n    public Route(String name, int routeNumber) {\n        this.name = name == null ? "" : name.replace("\\n", "")\n                .replace("\\r", "");\n        this.routeNumber = routeNumber;\n        this.vehicles = new ArrayList<>();\n        this.route = new ArrayList<>();\n    }\n\n    /**\n     * Returns the name of the route.\n     *\n     * @return The route name.\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the number of the route.\n     *\n     * @return The route number.\n     */\n    public int getRouteNumber() {\n        return routeNumber;\n    }\n\n    /**\n     * Returns the stops which comprise this route.\n     *\n     * <p>The order of the stops in the returned list should be the same as the\n     * order in which the stops were added to the route.\n     *\n     * <p>Modifying the returned list should not result in changes to the internal\n     * state of the class.\n     *\n     * @return The stops making up the route.\n     */\n    public List<Stop> getStopsOnRoute() {\n        return new ArrayList<>(route);\n    }\n\n    /**\n     * Returns the first stop of the route (i.e. the first stop to be added to the\n     * route).\n     *\n     * @return The start stop of the route.\n     * @throws EmptyRouteException If there are no stops currently on the route\n     */\n    public Stop getStartStop() throws EmptyRouteException {\n        if (route.isEmpty()) {\n            throw new EmptyRouteException();\n        }\n\n        return route.get(0);\n    }\n\n    /**\n     * Adds a stop to the route.\n     *\n     * <p>If the given stop is null, it should not be added to the route.\n     *\n     * <p>If this is the first stop to be added to the route, the given stop should\n     * be recorded as the starting stop of the route. Otherwise, the given stop\n     * should be recorded as a neighbouring stop of the previous stop on the route\n     * (and vice versa) using the {@link Stop#addNeighbouringStop(Stop)} method.\n     *\n     * <p>This route should also be added as a route of the given stop (if the given\n     * stop is not null) using the {@link Stop#addRoute(Route)} method.\n     *\n     * @param stop The stop to be added to this route.\n     */\n    public void addStop(Stop stop) {\n        if (stop == null) {\n            return;\n        }\n\n        stop.addRoute(this);\n        route.add(stop);\n\n        // return if this was the first stop\n        if (route.size() == 1) {\n            return;\n        }\n\n        Stop previous = route.get(route.size() - 2);\n        previous.addNeighbouringStop(stop);\n        stop.addNeighbouringStop(previous);\n    }\n\n    /**\n     * Returns the public transport vehicles currently on this route.\n     *\n     * <p>No specific order is required for the public transport objects in the\n     * returned list.\n     *\n     * <p>Modifying the returned list should not result in changes to the internal\n     * state of the class.\n     *\n     * @return The vehicles currently on the route.\n     */\n    public List<PublicTransport> getTransports() {\n        return new ArrayList<>(this.vehicles);\n    }\n\n    /**\n     * Adds a vehicle to this route.\n     *\n     * <p>If the given transport is null, it should not be added to the route.\n     *\n     * <p>The method should check for the transport being null first, then for an\n     * empty route, and then for incompatible types (in that order).</p>\n     *\n     * @param transport The vehicle to be added to the route.\n     * @throws EmptyRouteException       If there are not yet any stops on the route.\n     * @throws IncompatibleTypeException If the given vehicle is of the incorrect\n     *                                   type for this route. This depends on the type of the route, i.e. a\n     *                                   BusRoute can only accept Bus instances.\n     */\n    public void addTransport(PublicTransport transport)\n            throws EmptyRouteException, IncompatibleTypeException {\n        if (transport == null) {\n            return;\n        }\n\n        if (route.isEmpty()) {\n            throw new EmptyRouteException();\n        }\n\n        if (!getType().equals(transport.getType())) {\n            throw new IncompatibleTypeException();\n        }\n\n        vehicles.add(transport);\n    }\n\n    /**\n     * Compares this stop with another object for equality.\n     * <p>\n     * Two routes are equal if their names and route numbers are equal.\n     * <p>\n     * {@inheritDoc}\n     *\n     * @param other The other object to compare for equality.\n     * @return True if the objects are equal (as defined above), false otherwise\n     * (including if other is null or not an instance of the {@link Route}\n     * class.\n     */\n    @Override\n    public boolean equals(Object other) {\n        if (!(other instanceof Route)) {\n            return false;\n        }\n        Route otherRoute = (Route) other;\n        return name.equals(((Route) other).getName())\n                && routeNumber == otherRoute.getRouteNumber();\n    }\n\n    @Override\n    public int hashCode() {\n        return routeNumber;\n    }\n\n    /**\n     * Returns the type of this route.\n     *\n     * @return The type of the route (see subclasses)\n     */\n    public abstract String getType();\n\n    /**\n     * Creates a string representation of a route in the format:\n     *\n     * <p>\'{type},{name},{number}:{stop0}|{stop1}|...|{stopN}\'\n     *\n     * <p>without the surrounding quotes, and where {type} is replaced by the type\n     * of the route, {name} is replaced by the name of the route, {number} is replaced\n     * by the route number, and {stop0}|{stop1}|...|{stopN} is replaced by a list of\n     * the names of the stops stops making up the route. For example:\n     *\n     * <p>bus,red,1:UQ Lakes|City|Valley\n     *\n     * @return A string representation of the route.\n     */\n    @Override\n    public String toString() {\n        StringBuilder builder = new StringBuilder();\n\n        builder.append(getType()).append(",");\n        builder.append(name).append(",").append(routeNumber);\n        builder.append(":");\n\n        for (Stop stop : route) {\n\n\n            builder.append(stop.getName()).append("|");\n        }\n\n        if (!route.isEmpty()) {\n            builder.deleteCharAt(builder.length() - 1);\n        }\n\n        return builder.toString();\n    }\n\n    @Override\n    public String encode() {\n        return toString();\n    }\n\n    /**\n     * Creates a new route object based on the given string representation.\n     * The format of the string should match that returned by the encode() method.\n     * The correct stops should also be added to the decoded route using the\n     * addStop(Stop) method. If there are multiple stops in the\n     * existingStops list which have the same name, then the first stop in\n     * the list with a matching name should be used. This still applies if\n     * there are multiple stops in the routeString with the same name (i.e.\n     * they should both use the first stop in the list with a matching name).\n     *\n     * Whilst parsing, if spaces (i.e. \' \') are encountered before or after\n     * integers, (e.g. {number}), the spaces should simply be trimmed (for\n     * example, using something like String.trim()). If spaces are\n     * encountered before or after strings (e.g. {type}), the spaces should\n     * be considered part of the string and not handled differently from any other character.\n     * @param routeString The string to decode.\n     * @param existingStops  The stops which currently exist in the transport network.\n     * @return The decoded route object (a BusRoute, TrainRoute, or FerryRoute, depending on the type given in the string).\n     * @throws TransportFormatException -If the given string or\n     * existingStops list is null, or the string is incorrectly formatted\n     * (according to the encode() representation). This includes, but is not limited to:\n     * A route type that is not one of "bus", "train", or "ferry".\n     * The route number is not an integer value.\n     * The stop name given in the string does not match one of the given existingStops.\n     * Any extra delimiters (, : |) being encountered whilst parsing.\n     * Any of the parts of the string being missing. This includes empty\n     * strings as stop names in the routeString (e.g. \'bus,red,1:||\'). A\n     * routeString with no stops (e.g. \'bus,red,1:\') is, however, valid. A\n     * routeString with an empty name is also valid (as this is allowed by the Route constructor).\n     */\n    public static Route decode(String routeString, List<Stop> existingStops)\n            throws TransportFormatException {\n        if (!routeString.contains(":") || routeString.split(":").length > 2) {\n            throw new TransportFormatException();\n        }\n        String[] routeInfo = routeString.split(":")[0].split(",");\n        if (routeInfo.length != 3) {\n\n\n            throw new TransportFormatException();\n        }\n        int id;\n        try {\n            id = Integer.parseInt(routeInfo[2].trim());\n        } catch (NumberFormatException e) {\n            throw new TransportFormatException();\n        }\n        Route route;\n        switch (routeInfo[0]) {\n            case "bus":\n                route = new BusRoute(routeInfo[1], id);\n                break;\n            case "ferry":\n                route = new FerryRoute(routeInfo[1], id);\n                break;\n            case "train":\n                route = new TrainRoute(routeInfo[1], id);\n                break;\n            default:\n                throw new TransportFormatException();\n        }\n        if (!routeString.endsWith(":")) {\n            String[] stopsInfo = routeString.split(":")[1].split("\\\\|");\n            for (int i = 0; i < stopsInfo.length; i++) {\n                for (Stop stop : existingStops) {\n                    if (stop.getName().equals(stopsInfo[i])) {\n                        route.addStop(stop);\n                        break;\n                    }\n                }\n            }\n            if (route.getStopsOnRoute().size() != stopsInfo.length) {\n                throw new TransportFormatException();\n            }\n        }\n        return route;\n    }\n}\n', 'Stop.java': 'package stops;\n\nimport exceptions.NoNameException;\nimport exceptions.TransportFormatException;\nimport passengers.Passenger;\nimport routes.Route;\nimport utilities.Writeable;\nimport vehicles.PublicTransport;\n\nimport java.util.*;\n\n/**\n * Represents a stop in the transportation network.\n *\n * <p>Stops are where public transport vehicles collect and drop off passengers,\n * and are located along one or more routes.\n */\npublic class Stop implements Writeable {\n    // the name of the stop\n    private String name;\n\n    // the passengers currently waiting at the stop\n    private List<Passenger> passengers;\n\n    // the routes which this stop is located on\n    private List<Route> routes;\n\n    // the vehicles currently at this stop\n    private Set<PublicTransport> atStop;\n\n    // the stops directly adjacent to this stop along routes\n    private List<Stop> neighbours;\n\n    // the x and y coordinates of this stop\n    private int xCoordinate;\n    private int yCoordinate;\n\n\n    /**\n     * Creates a new Stop object with the given name and coordinates.\n     *\n     * <p>A stop should be created with no passengers, routes, or vehicles.\n     *\n     * <p>If the given name contains any newline characters (\'\\n\') or carriage returns\n     * (\'\\r\'), they should be removed from the string before it is stored.\n     *\n     * @param name The name of the stop being created.\n     * @param x    The x coordinate of the stop being created.\n     * @param y    The y coordinate of the stop being created.\n     * @throws NoNameException If the given name is null or empty.\n     */\n    public Stop(String name, int x, int y) {\n        if (name == null || name.isEmpty()) {\n            throw new NoNameException();\n        }\n        this.name = name.replace("\\n", "")\n                .replace("\\r", "");\n        this.xCoordinate = x;\n        this.yCoordinate = y;\n\n        this.neighbours = new ArrayList<>();\n        this.passengers = new ArrayList<>();\n        this.routes = new ArrayList<>();\n        this.atStop = new HashSet<>();\n    }\n\n    /**\n     * Returns the name of this stop.\n     *\n     * @return The name of the stop.\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the x-coordinate of this stop.\n     *\n     * @return The x-coordinate of the stop.\n     */\n    public int getX() {\n        return xCoordinate;\n    }\n\n    /**\n     * Returns the y-coordinate of this stop.\n     *\n     * @return The y-coordinate of the stop.\n     */\n    public int getY() {\n        return yCoordinate;\n    }\n\n    /**\n     * Records that this stop is part of the given route.\n     * <p>\n     * If the given route is null, it should not be added to the stop.\n     *\n     * @param route The route to be added.\n     */\n    public void addRoute(Route route) {\n        if (route == null) {\n            return;\n        }\n        routes.add(route);\n    }\n\n    /**\n     * Returns the routes associated with this stop.\n     *\n     * <p>No specific order is required for the route objects in the returned list.\n     *\n     * <p>Modifying the returned list should not result in changes to the internal\n     * state of the class.\n     *\n     * @return The routes which go past the stop.\n     */\n    public List<Route> getRoutes() {\n        return new ArrayList<>(routes);\n    }\n\n    /**\n     * Records the given stop as being a neighbour of this stop.\n     *\n     * <p>If the given stop is null, or if this stop is already recorded as a neighbour,\n     * it should not be added as a neighbour, and the method should return early.\n     *\n     * @param neighbour The stop to add as a neighbour.\n     */\n    public void addNeighbouringStop(Stop neighbour) {\n        if (neighbour == null || neighbours.contains(neighbour)) {\n            return;\n        }\n        neighbours.add(neighbour);\n    }\n\n    /**\n     * Returns all of the stops adjacent to this one on any routes.\n     *\n     * <p>No specific order is required for the stop objects in the returned list.\n     *\n     * <p>Modifying the returned list should not result in changes to the internal\n     * state of the class.\n     *\n     * @return The neighbours of this stop.\n     */\n    public List<Stop> getNeighbours() {\n        return new ArrayList<>(neighbours);\n    }\n\n    /**\n     * Places a passenger at this stop.\n     *\n     * <p>If the given passenger is null, it should not be added to the stop.\n     *\n     * @param passenger The passenger to add to the stop.\n     */\n    public void addPassenger(Passenger passenger) {\n        if (passenger == null) {\n            return;\n        }\n        this.passengers.add(passenger);\n    }\n\n    /**\n     * Returns the passengers currently at this stop.\n     *\n     * <p>The order of the passengers in the returned list should be the same as the\n     * order in which the passengers were added to the stop.\n     *\n     * <p>Modifying the returned list should not result in changes to the internal\n     * state of the class.\n     *\n     * @return The passengers currently waiting at the stop.\n     */\n    public List<Passenger> getWaitingPassengers() {\n        return new ArrayList<>(passengers);\n    }\n\n    /**\n     * Checks whether the given public transport vehicle is at this stop or not.\n     *\n     * @param transport The transport vehicle to check for.\n     * @return True if the vehicle is at this stop, false otherwise.\n     */\n    public boolean isAtStop(PublicTransport transport) {\n        return atStop.contains(transport);\n    }\n\n    /**\n     * Returns the vehicles currently at this stop.\n     *\n     * <p>No specific order is required for the public transport objects in the\n     * returned list.\n     *\n     * <p>Modifying the returned list should not result in changes to the internal\n     * state of the class.\n     *\n     * @return The vehicles currently at the stop.\n     */\n    public List<PublicTransport> getVehicles() {\n        return new ArrayList<>(atStop);\n    }\n\n    /**\n     * Records a public transport vehicle arriving at this stop. There is no limit\n     * on the number of vehicles that can be at a stop simultaneously.\n     *\n     * <p>If the given vehicle is already at this stop, or if the vehicle is null,\n     * do nothing.\n     *\n     * <p>Otherwise, unload all of the passengers on the arriving vehicle (using\n     * {@link PublicTransport#unload()}), and place them at this stop, as well as\n     * recording the vehicle itself at this stop.\n     *\n     * <p>This method does not need to check whether this stop is on the given transport\'s\n     * route, or whether the transport\'s route is a route of this stop, and should\n     * also not update the location of the transport.\n     *\n     * @param transport The public transport vehicle arriving at this stop.\n     */\n    public void transportArrive(PublicTransport transport) {\n        if (transport == null || isAtStop(transport)) {\n            return;\n        }\n\n        List<Passenger> arriving = transport.unload();\n        for (Passenger passenger : arriving) {\n            addPassenger(passenger);\n        }\n\n        atStop.add(transport);\n    }\n\n    /**\n     * Records a public transport vehicle departing this stop and travelling to a\n     * new stop.\n     *\n     * <p>This method should also update the vehicle\'s location to be the next stop\n     * (using {@link PublicTransport#travelTo(Stop)}).\n     *\n     * <p>If the given vehicle is not at this stop, or if the vehicle is null, or\n     * if the next stop is null, do nothing.\n     *\n     * @param transport The transport currently leaving this stop.\n     * @param nextStop  The stop which the transport is travelling to.\n     */\n    public void transportDepart(PublicTransport transport, Stop nextStop) {\n        if (!isAtStop(transport) || nextStop == null) {\n            return;\n        }\n        transport.travelTo(nextStop);\n        atStop.remove(transport);\n    }\n\n    /**\n     * Returns the Manhattan distance between this stop and the given other stop.\n     *\n     * <p>Manhattan distance between two points, for example (x1, y1) and (x2, y2),\n     * is calculated using the following formula:<br>\n     * abs(x1 - x2) + abs(y1 - y2)<br>\n     * where abs is a method that calculates the absolute value of a number.\n     *\n     * @param stop The stop to calculate the Manhattan distance to.\n     * @return The Manhattan distance between this stop and the given stop (or -1\n     * if the given stop is null)\n     */\n    public int distanceTo(Stop stop) {\n        if (stop == null) {\n            return -1;\n        }\n        return Math.abs(getX() - stop.getX()) + Math.abs(getY() - stop.getY());\n    }\n\n    /**\n     * Compares this stop to the other object for equality.\n     *\n     * <p>Two stops are considered equal if they have the same name, x-coordinate,\n     * y-coordinate, and routes. Routes may be in any order, as long as all of this\n     * stop\'s routes are also associated with the other stop, and vice versa. Duplicates\n     * of routes do not need to be considered in determining equality (that is,\n     * if this stop has routes R1 and R2, and other has routes R1, R2, and R1 again,\n     * their routes can still be considered equal, ignoring duplicates).\n     * <p>\n     * {@inheritDoc}\n     *\n     * @param other the other object to compare for equality.\n     * @return True if the objects are equal (as defined above), false otherwise\n     * (including if other is null or not an instance of the {@link Stop}\n     * class.\n     */\n    @Override\n    public boolean equals(Object other) {\n        if (!(other instanceof Stop)) {\n            return false;\n        }\n        Stop otherStop = (Stop) other;\n        return this.name.equals(otherStop.getName())\n                && this.xCoordinate == otherStop.getX()\n                && this.yCoordinate == otherStop.getY()\n                && new HashSet<>(this.routes).equals(new HashSet<>(otherStop\n                .getRoutes()));\n    }\n\n    @Override\n    public int hashCode() {\n\n\n        return this.name.hashCode();\n    }\n\n    /**\n     * Creates a string representation of a stop in the format:\n     *\n     * <p>\'{name}:{x}:{y}\'\n     *\n     * <p>without the surrounding quotes, and where {name} is replaced by the name\n     * of the stop, {x} is replaced by the x-coordinate of the stop, and {y} is\n     * replaced by the y-coordinate of the stop.\n     *\n     * @return A string representation of the stop.\n     */\n    @Override\n    public String toString() {\n        return name + ":" + xCoordinate + ":" + yCoordinate;\n    }\n\n    /**\n     * Encodes this stop as a string in the same format as specified in toString().\n     * @return This stop encoded as a string.\n     */\n    @Override\n    public String encode() {\n        return toString();\n    }\n\n    /**\n     * Creates a new stop object based on the given string representation.\n     * The format of the string should match that returned by the encode() method.\n     *\n     * Whilst parsing, if spaces (i.e. \' \') are encountered before or after\n     * integers, (e.g. {x}), the spaces should simply be trimmed (for\n     * example, using something like String.trim()). If spaces are\n     * encountered before or after strings (e.g. {name}), the spaces should\n     * be considered part of the string and not handled differently from any other character.\n     *\n     * Parameters:\n     * @param stopString The string to decode.\n     * @return The decoded stop object.\n     * @throws TransportFormatException -If the given string is null, or the\n     * string is incorrectly formatted (according to the encode()\n     * representation). This includes, but is not limited to:\n     * x- or y- coordinates that are not integer values.\n     * Any extra delimiters (:) being encountered whilst parsing.\n     * Any of the parts of the string being missing. This includes a missing\n     * stop name (as this is defined as invalid according to the Stop constructor).\n     */\n    public static Stop decode(String stopString)\n            throws TransportFormatException {\n        int count = 0;\n        for (int i = 0; i < stopString.length(); i++) {\n            if (stopString.charAt(i) == \':\') {\n                count++;\n            }\n        }\n        if (count != 2) {\n            throw new TransportFormatException();\n        }\n        String[] stopInfo = stopString.split(":");\n        Stop stop;\n        try {\n            String x = stopInfo[1].trim();\n            String y = stopInfo[2].trim();\n            stop = new Stop(stopInfo[0], Integer.parseInt(x),\n                    Integer.parseInt(y));\n        } catch (NumberFormatException e) {\n            throw new TransportFormatException();\n        } catch (NoNameException e) {\n            throw new TransportFormatException();\n        }\n\n\n        return stop;\n    }\n}\n', 'Train.java': 'package vehicles;\n\nimport routes.Route;\n\n/**\n * Represents a train in the transportation network.\n */\npublic class Train extends PublicTransport {\n    // the number of carriages the train has\n    private int carriageCount;\n\n    /**\n     * Creates a new Train object with the given id, capacity, route, and carriage\n     * count.\n     *\n     * <p>Should meet the specification of {@link PublicTransport#PublicTransport(int, int, Route)},\n     * as well as extending it to include the following:\n     *\n     * <p>If the given carriage count is less than or equal to zero, then 1 should be\n     * stored instead.\n     *\n     * @param id The identifying number of the train.\n     * @param capacity The maximum capacity of the train.\n     * @param route The route this train is on.\n     * @param carriageCount The number of carriages this train has.\n     */\n    public Train(int id, int capacity, Route route, int carriageCount) {\n        super(id, capacity, route);\n        this.carriageCount = Math.max(carriageCount, 1);\n    }\n\n    /**\n     * Returns the number of carriages this train has.\n     *\n     * @return The number of carriages the train has.\n     */\n    public int getCarriageCount() {\n        return carriageCount;\n    }\n\n    /**\n     * Encodes this train as a string in the same format as specified in\n     * PublicTransport.encode(), but with an additional component at the\n     * end, namely the carriage count. The encoded format should be as follows:\n     * \'{type},{id},{capacity},{route},{carriages}\'\n     *\n     * where {carriages} is replaced by the carriage count of this train,\n     * and all of the other components are the same as defined in the method being overridden.\n     * For example:\n     *\n     * train,3,100,3,5\n     * @return This train encoded as a string.\n     */\n    @Override\n    public String encode() {\n        return super.encode() + "," + this.carriageCount;\n    }\n}\n', 'TrainRoute.java': 'package routes;\n\n/**\n * Represents a train route in the transportation network.\n */\npublic class TrainRoute extends Route {\n\n    /**\n     * Creates a new TrainRoute with the given name and number.\n     *\n     * <p>Should meet the specification of {@link Route#Route(String, int)}\n     *\n     * @param name The name of the route.\n     * @param routeNumber The route number of the route.\n     */\n    public TrainRoute(String name, int routeNumber) {\n        super(name, routeNumber);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @return "train"\n     */\n    @Override\n    public String getType() {\n        return "train";\n    }\n}\n', 'TransportException.java': 'package exceptions;\n\n/**\n * Base class for custom exceptions related to the transportation network.\n */\npublic class TransportException extends Exception {\n}\n', 'TransportFormatException.java': 'package exceptions;\n\n/**\n * Exception thrown when an encoded Network file is formatted incorrectly.\n */\npublic class TransportFormatException extends TransportException {\n}\n', 'Writeable.java': 'package utilities;\n\n/**\n * Creates a string representation of the object for writing to a file.\n * See implementing classes for specific implementation details.\n * Returns:\n * A string representation of the object.\n */\npublic interface Writeable {\n    String encode();\n}\n'}, {'Bus.java': 'package vehicles;\n\nimport routes.Route;\n\n/**\n * Represents a bus in the transportation network.\n */\npublic class Bus extends PublicTransport {\n    // the rego of the bus\n    private String registrationNumber;\n\n    /**\n     * Creates a new Bus object with the given id, capacity, route, and registration\n     * number.\n     *\n     * <p>Should meet the specification of {@link PublicTransport#PublicTransport(int, int, Route)},\n     * as well as extending it to include the following:\n     *\n     * <p>If the given registration number is null, an empty string should be stored\n     * instead. If the registration number contains any newline characters (\'\\n\')\n     * or carriage returns (\'\\r\'), they should be removed from the string before\n     * it is stored.\n     *\n     * @param id The identifying number of the bus.\n     * @param capacity The maximum capacity of the bus.\n     * @param route The route this bus is on.\n     * @param registrationNumber The registration number of the bus.\n     */\n    public Bus(int id, int capacity, Route route, String registrationNumber) {\n        super(id, capacity, route);\n        this.registrationNumber = registrationNumber == null ? "" : registrationNumber\n                .replace("\\n", "").replace("\\r", "");\n    }\n\n    /**\n     * Returns the registration number of this bus.\n     *\n     * @return The registration number of the bus.\n     */\n    public String getRegistrationNumber() {\n        return registrationNumber;\n    }\n\n    /**\n     * Encodes this bus as a string in the same format as specified in PublicTransport.encode(),\n     * but with an additional component at the end, namely the bus registration number.\n     * The encoded format should be as follows:\n     * \'{type},{id},{capacity},{route},{registration}\'\n     *\n     * where {registration} is replaced by the registration number of this bus, and all of the other components\n     * are the same as defined in the method being overridden. For example:\n     *\n     * bus,1,30,1,ABC123\n     * @return String representing this Bus\n     */\n    @Override\n    public String encode() {\n        return super.encode() + \',\' + registrationNumber;\n    }\n}\n', 'BusRoute.java': 'package routes;\n\n/**\n * Represents a bus route in the transportation network.\n */\npublic class BusRoute extends Route {\n\n    /**\n     * Creates a new BusRoute with the given name and number.\n     *\n     * <p>Should meet the specification of {@link Route#Route(String, int)}\n     *\n     * @param name The name of the route.\n     * @param routeNumber The route number of the route.\n     */\n    public BusRoute(String name, int routeNumber) {\n        super(name, routeNumber);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @return "bus"\n     */\n    @Override\n    public String getType() {\n        return "bus";\n    }\n}\n', 'ConcessionPassenger.java': 'package passengers;\n\nimport stops.Stop;\n\n/**\n * A passenger that pays concession fares. Concession fares require a concession id.\n */\npublic class ConcessionPassenger extends Passenger {\n    // concession id for validating concession fares\n    private int concessionId;\n\n    // whether the concession passenger has a valid concession id\n    private static final int INVALID = -1;\n\n    /**\n     * Construct a new concession fare passenger with the given name and concessionId.\n     *\n     * <p>Should meet the specification of {@link Passenger#Passenger(String, Stop)}.\n     *\n     * @param name The name of the passenger.\n     * @param destination The destination of the passenger.\n     * @param concessionId Identifying number of the passenger\'s concession card.\n     */\n    public ConcessionPassenger(String name, Stop destination, int concessionId) {\n        super(name, destination);\n        renew(concessionId);\n    }\n\n    /**\n     * Sets the concession fare to be expired, and thus invalid. {@link #isValid()}\n     * returns false.\n     */\n    public void expire() {\n        this.concessionId = INVALID;\n    }\n\n    /**\n     * Attempts to renew this concession passenger\'s fares with the given id.\n     *\n     * @param newId The ID of the renewed concession card.\n     */\n    public void renew(int newId) {\n        if (newId < 0 || Integer.toString(newId).length() < 6\n                || !Integer.toString(newId).startsWith("42")) {\n            this.concessionId = INVALID;\n        } else {\n            this.concessionId = newId;\n        }\n    }\n\n    /**\n     * Returns true if and only if the stored concessionId is valid.\n     *\n     * <p>In this transportation network, a valid concessionId begins with the digits\n     * \'42\', should be positive, and should be a minimum of six digits in length\n     * (for example, 420000 would be a valid concessionId, while 430000, -420000,\n     * or 42000 would not).\n     *\n     * @return True if concession fares have not expired (are valid), false otherwise.\n     */\n    public boolean isValid() {\n        return this.concessionId != INVALID;\n    }\n}\n', 'EmptyRouteException.java': 'package exceptions;\n\nimport routes.Route;\nimport vehicles.PublicTransport;\n\n/**\n * Exception thrown when a {@link PublicTransport} is added to a\n * {@link Route} with no {@link stops.Stop}s.\n */\npublic class EmptyRouteException extends TransportException {\n}\n', 'Ferry.java': 'package vehicles;\n\nimport routes.Route;\n\n/**\n * Represents a ferry in the transportation network.\n */\npublic class Ferry extends PublicTransport {\n    // the type of the ferry\n    private String ferryType;\n\n    /**\n     * Creates a new Ferry object with the given id, capacity, route, and type.\n     *\n     * <p>Should meet the specification of {@link PublicTransport#PublicTransport(int, int, Route)},\n     * as well as extending it to include the following:\n     *\n     * <p>If the given ferryType is null or empty, the string "CityCat" should be\n     * stored instead. If the ferry type contains any newline characters (\'\\n\')\n     * or carriage returns (\'\\r\'), they should be removed from the string before\n     * it is stored.\n     *\n     * @param id The identifying number of the ferry.\n     * @param capacity The maximum capacity of the ferry.\n     * @param route The route this ferry is on.\n     * @param ferryType The type of the ferry (e.g. CityCat).\n     */\n    public Ferry(int id, int capacity, Route route, String ferryType) {\n        super(id, capacity, route);\n        this.ferryType = ferryType == null || ferryType.isEmpty() ? "CityCat" :\n                ferryType.replace("\\n", "").replace("\\r", "");\n    }\n\n    /**\n     * Returns the type of this ferry.\n     *\n     * @return The type of the ferry.\n     */\n    public String getFerryType() {\n        return ferryType;\n    }\n\n    /**\n     * Encodes this ferry as a string in the same format as specified in PublicTransport.encode(),\n     * but with an additional component at the end, namely the ferry type.\n     * The encoded format should be as follows:\n     * \'{type},{id},{capacity},{route},{ferryType}\'\n     *\n     * where {ferryType} is replaced by the type of this ferry, and all of the other components are the same as\n     * defined in the method being overridden.\n     * For example:\n     *\n     * ferry,2,50,2,CityCat\n     * @return String representation of this Ferry\n     */\n    @Override\n    public String encode() {\n        return super.encode() + \',\' + ferryType;\n    }\n}\n', 'FerryRoute.java': 'package routes;\n\n/**\n * Represents a ferry route in the transportation network.\n */\npublic class FerryRoute extends Route {\n\n    /**\n     * Creates a new FerryRoute with the given name and number.\n     *\n     * <p>Should meet the specification of {@link Route#Route(String, int)}\n     *\n     * @param name The name of the route.\n     * @param routeNumber The route number of the route.\n     */\n    public FerryRoute(String name, int routeNumber) {\n        super(name, routeNumber);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @return "ferry"\n     */\n    @Override\n    public String getType() {\n        return "ferry";\n    }\n}\n', 'IncompatibleTypeException.java': 'package exceptions;\n\nimport routes.Route;\nimport vehicles.PublicTransport;\n\n/**\n * Exception thrown when a subclass of {@link PublicTransport} is\n * added to a {@link Route} for a different type of transport.\n *\n * i.e. Train added to BusRoute\n */\npublic class IncompatibleTypeException extends TransportException {\n}\n', 'Network.java': "package network;\n\nimport exceptions.TransportFormatException;\nimport routes.Route;\nimport stops.Stop;\nimport vehicles.PublicTransport;\n\nimport java.io.*;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\n/**\n * Represents the transportation network, and manages all of the various components therein.\n */\npublic class Network {\n    //Ordered List of stops in the network\n\n\n    private LinkedList<Stop> stops;\n    //Ordered List of routes in the network\n    private LinkedList<Route> routes;\n    //Ordered List of vehicles in the network\n    private LinkedList<PublicTransport> vehicles;\n\n    /**\n     * Creates a new empty Network with no stops, vehicles, or routes.\n     */\n    public Network(){\n        stops = new LinkedList<>();\n        routes = new LinkedList<>();\n        vehicles = new LinkedList<>();\n    }\n\n    /**\n     * Creates a new Network from information contained in the file indicated by the given filename\n     * The file should be in the following format:\n     * {number_of_stops}\n     * {stop0:x0:y0}\n     * ...\n     * {stopN:xN:yN}\n     * {number_of_routes}\n     * {type0,name0,number0:stop0|stop1|...|stopM}\n     * ...\n     * {typeN,nameN,numberN:stop0|stop1|...|stopM}\n     * {number_of_vehicles}\n     * {type0,id0,capacity0,routeNumber,extra}\n     * ...\n     * {typeN,idN,capacityN,routeNumber,extra}\n     * where {number_of_stops}, {number_of_routes}, and {number_of_vehicles} are the number of stops, routes,\n     * and vehicles (respectively) in the network, and where {stop0,x0,y0} is the encode() representation of a Stop,\n     * {type0,name0,number0:stop0|stop1|...|stopM} is the encode() representation of a Route,and\n     * {typeN,idN,capacityN,routeNumber,extra} is the encode() representation of a PublicTransport.\n     * @param filename The name of the file to load the network from\n     * @throws TransportFormatException If any of the lines representing stops, routes, or vehicles are incorrectly\n     * formatted according to their respective decode methods (i.e. if their decode method throws an exception).\n     * @throws TransportFormatException If any of the integers are incorrectly formatted (i.e. cannot be parsed).\n     * @throws TransportFormatException If the {number_of_stops} does not match the actual number of lines\n     * representing stops present. This also applies to {number_of_routes} and {number_of_vehicles}.\n     * An error should also be thrown if any of these integers are negative.\n     * @throws TransportFormatException If there are any extra lines present in the file (the file may end with a\n     * single newline character, but there may not be multiple blank lines at the end of the file)\n     * @throws TransportFormatException If any other formatting issues are encountered whilst parsing the file\n     * @throws IOException If any IO exceptions occur whilst trying to read from the file, or if the filename is null.\n     */\n    public Network(String filename) throws TransportFormatException,IOException {\n        if(filename == null) throw new IOException();\n        //Init lists\n        stops = new LinkedList<>();\n        routes = new LinkedList<>();\n        vehicles = new LinkedList<>();\n        //Read file into array and process it line by line with iterator\n        ArrayList<String> lines;\n        try (Stream<String> stream = Files.lines(Paths.get(filename))) {\n            lines = new ArrayList<>(stream.collect(Collectors.toList()));\n        }\n        Iterator<String> it = lines.iterator();\n        //Filter empty files\n        if(!it.hasNext())\n            throw new TransportFormatException();\n        int numOfStops;\n        try{\n            numOfStops = Integer.parseInt(it.next());\n        }\n        catch (NumberFormatException ex)\n        {\n            throw new TransportFormatException();\n        }\n        //Ban negative numbers\n        if(numOfStops <= 0) throw new TransportFormatException();\n        //Same logic for the remaining part of file, we check that the next line actually exists and if it does\n        //we try to decode it into corresponding object or throw exception otherwise, we trust decode method to determine\n        //whether or not it has been given a right object to parse so if given number of lines is too small decode will\n        //throw TransportFormatException, if it is too big we will hit end of file or next number which will cause same\n        //exception to be thrown\n        for(int i = 0;i < numOfStops;i++)\n        {\n            if(it.hasNext())\n                addStop(Stop.decode(it.next()));\n            else\n                throw new TransportFormatException();\n        }\n        if(!it.hasNext())\n            throw new TransportFormatException();\n        int numOfRoutes;\n        try{\n            numOfRoutes = Integer.parseInt(it.next());\n        }\n        catch (NumberFormatException ex)\n        {\n            throw new TransportFormatException();\n        }\n        if(numOfRoutes<=0) throw new TransportFormatException();\n        for(int i = 0; i < numOfRoutes; i++){\n            if(it.hasNext())\n                addRoute(Route.decode(it.next(),stops));\n            else\n                throw new TransportFormatException();\n        }\n        if(!it.hasNext())\n            throw new TransportFormatException();\n        int numOfVehicles;\n        try{\n            numOfVehicles = Integer.parseInt(it.next());\n        }\n        catch (NumberFormatException ex)\n        {\n            throw new TransportFormatException();\n        }\n        if(numOfVehicles <= 0) throw new TransportFormatException();\n        for(int i =0;i<numOfVehicles;i++){\n            if(it.hasNext())\n                addVehicle(PublicTransport.decode(it.next(),routes));\n            else\n                throw new TransportFormatException();\n        }\n        //If we are here we have got all the info specified by format so if we have any more content - formatting is wrong\n\n\n        if(it.hasNext())\n            throw new TransportFormatException();\n    }\n\n    /**\n     * Adds route to the network if it is not null\n     * @param route Route to be added\n     */\n    public void\taddRoute(Route route){\n        if(route != null)\n            routes.add(route);\n    }\n\n    /**\n     * Adds stop to the network if it is not null\n     * @param stop Stop to be added\n     */\n    public void\taddStop(Stop stop){\n        if(stop != null)\n            stops.add(stop);\n    }\n\n    /**\n     * Adds multiple stops to the network in transactional manner(either all or none) if all of them are not null\n     * @param stops Stops to be added\n     */\n    public void\taddStops(List<Stop> stops){\n        for (Stop s: stops) {\n            if(s == null) return;\n        }\n\n\n        this.stops.addAll(stops);\n    }\n\n    /**\n     * Adds vehicle to the network if it is not null\n     * @param vehicle Vehicle to be added\n     */\n    public void\taddVehicle(PublicTransport vehicle){\n        if(vehicle != null)\n            vehicles.add(vehicle);\n    }\n\n    /**\n     * Returns ordered copy of network's list of routes\n     * @return List of routes in network in the order they were added\n     */\n    public List<Route> getRoutes(){\n        return new LinkedList<>(routes);\n    }\n\n    /**\n     * Returns ordered copy of network's list of stops\n     * @return List of stops in network in the order they were added\n     */\n    public List<Stop> getStops(){\n        return new LinkedList<>(stops);\n    }\n\n    /**\n     * Returns ordered copy of network's list of vehicles\n     * @return List of vehicles in network in the order they were added\n     */\n    public List<PublicTransport> getVehicles(){\n        return new LinkedList<>(vehicles);\n    }\n\n    /**\n     * Saves this network to the file indicated by the given filename.\n     * The file is written with the same format as described in the Network(String) constructor.\n     *\n     * The stops,vehicles and routes are written to the file in the same order in which they were added to the network.\n     *\n     * If the given filename is null, the method does nothing\n     * @param filename Name of the file to write to\n     * @throws IOException If there are any IO errors whilst writing to the file.\n     */\n    public void\tsave(String filename) throws IOException {\n        //Ignore null filenames\n        if(filename == null) return;\n        File file = new File(filename);\n        FileOutputStream fos = new FileOutputStream(file);\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(fos));\n        //Writing stops first\n        bw.write(Integer.toString(stops.size()));\n        bw.newLine();\n        for (Stop s: stops) {\n            bw.write(s.encode());\n            bw.newLine();\n        }\n        //Then routes\n        bw.write(Integer.toString(routes.size()));\n        bw.newLine();\n        for (Route r: routes) {\n            bw.write(r.encode());\n            bw.newLine();\n        }\n        //And finally vehicles\n        bw.write(Integer.toString(vehicles.size()));\n        bw.newLine();\n        for (PublicTransport p:vehicles) {\n            bw.write(p.encode());\n            bw.newLine();\n        }\n        bw.close();\n    }\n}\n", 'NetworkTest.java': 'package network;\n\nimport exceptions.TransportFormatException;\nimport org.junit.Test;\nimport routes.BusRoute;\nimport routes.FerryRoute;\n\nimport stops.Stop;\nimport vehicles.Bus;\nimport vehicles.Ferry;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class NetworkTest {\n    @Test\n\n\n    public void emptyNetworkTest(){\n        Network emptyNetwork = new Network();\n        assert emptyNetwork.getRoutes().isEmpty();\n        assert emptyNetwork.getStops().isEmpty();\n        assert emptyNetwork.getVehicles().isEmpty();\n    }\n\n    @Test\n    public void networkRouteTest(){\n        Network emptyNetwork = new Network();\n        BusRoute route = new BusRoute("check",1);\n        FerryRoute route2 = new FerryRoute("test",2);\n        emptyNetwork.addRoute(route);\n        assert emptyNetwork.getRoutes().contains(route);\n        emptyNetwork.addRoute(route2);\n        assert emptyNetwork.getRoutes().size() == 2;\n        //make sure it does not affect original collection\n        emptyNetwork.getRoutes().clear();\n        assert emptyNetwork.getRoutes().size() == 2;\n        emptyNetwork.addRoute(null);\n        assert emptyNetwork.getRoutes().size() == 2;\n        //Check order\n\n\n        assert emptyNetwork.getRoutes().get(0).equals(route);\n        assert emptyNetwork.getRoutes().get(1).equals(route2);\n    }\n\n    @Test\n    public void networkStopTest(){\n        Network n = new Network();\n        Stop st = new Stop("test",1,2);\n\n\n        Stop st2 = new Stop("check",2,2);\n        Stop st3 = new Stop("some other",4,2);\n        n.addStop(st);\n        assert  n.getStops().contains(st);\n        n.addStops(Arrays.asList(st2,st3));\n        assert n.getStops().contains(st2) && n.getStops().contains(st3);\n        n.getStops().clear();\n        assert n.getStops().size() == 3;\n        n.addStop(null);\n        assert n.getStops().size() == 3;\n        n.addStops(Arrays.asList(st,null));\n        assert n.getStops().size() == 3;\n        assert n.getStops().get(0).equals(st);\n        assert n.getStops().get(1).equals(st2);\n        assert n.getStops().get(2).equals(st3);\n    }\n\n    @Test\n    public void networkVehiclesTest(){\n        Network n = new Network();\n        BusRoute r = new BusRoute("test",4);\n        FerryRoute fr = new FerryRoute("check",5);\n        Bus v1 = new Bus(1,2,r,"ABC");\n        Ferry v2 = new Ferry(1,2,fr,"Red hopper");\n        n.addVehicle(v1);\n        assert n.getVehicles().contains(v1);\n        n.addVehicle(v2);\n        assert n.getVehicles().size() == 2;\n        n.getVehicles().clear();\n        assert n.getVehicles().size() == 2;\n        assert n.getVehicles().get(0).equals(v1) && n.getVehicles().get(1).equals(v2);\n\n\n        n.addVehicle(null);\n        assert n.getVehicles().size() == 2;\n    }\n\n    @Test\n    public void networkSaveTest(){\n        //Create a really simple network, save it, load it back\n        Network n = new Network();\n        Stop stop = new Stop("Check",1,2);\n        Stop anotherStop = new Stop("Test stop",-2,4);\n        Stop thirdStop = new Stop("Last stop", 0, 0);\n        n.addStop(stop);\n        n.addStop(anotherStop);\n        n.addStop(thirdStop);\n        BusRoute route = new BusRoute("red",24);\n\n\n        FerryRoute anotherRoute = new FerryRoute("blue",25);\n        route.addStop(stop);\n        anotherRoute.addStop(anotherStop);\n        anotherRoute.addStop(thirdStop);\n        n.addRoute(route);\n        n.addRoute(anotherRoute);\n        Bus bus = new Bus(1,5,route,"ABC245");\n        Ferry ferry = new Ferry(2,25,anotherRoute,"Red ferry");\n        n.addVehicle(bus);\n        n.addVehicle(ferry);\n        try{\n            n.save(null);\n        } catch (Exception ex){ assert false; }\n        try{\n            n.save("testingfile");\n        } catch (Exception ex) {assert false; }\n        try{\n            Network nBack = new Network("testingfile");\n            assert nBack.getVehicles().get(0).toString().equals(bus.toString());\n            assert nBack.getRoutes().get(0).equals(route);\n            assert nBack.getStops().get(0).equals(stop);\n        } catch (Exception ex) { assert false; }\n    }\n\n    @Test\n    public void checkingWrongCases(){\n        ArrayList<String> names = new ArrayList<>();\n        names.add("invalidBlankLines.txt");\n        names.add("invalidRouteEmptyStopNames.txt");\n        names.add("invalidRouteStops.txt");\n        names.add("invalidRouteTypes.txt");\n        names.add("invalidStopDelimiters.txt");\n        names.add("invalidTransportIntegers.txt");\n        names.add("invalidTransportPartsMissing.txt");\n        names.add("invalidWrongCountLess.txt");\n        names.add("invalidWrongCountMore.txt");\n        names.add("invalidEmptyExtra.txt");\n        names.add("invalidMissingStops.txt");\n        names.add("invalidTransportTypes.txt");\n        names.add("invalidNegativeCount.txt");\n        for (String name: names) {\n            try {\n                Network n = new Network("test/network/" + name);\n                assert false;\n            } catch (Exception ex){ assert ex instanceof TransportFormatException; }\n        }\n    }\n\n    @Test\n    public void checkingRightCases(){\n        ArrayList<String> names = new ArrayList<>();\n        names.add("validEmptyRoute.txt");\n        names.add("validFromSpec.txt");\n        names.add("validFromSpecStopsWithSpaces.txt");\n        names.add("validDifferentRoutes.txt");\n        names.add("validSimpleNetwork.txt");\n        for (String name: names) {\n            try {\n                Network n = new Network("test/network/" + name);\n            } catch (Exception ex){ assert false; }\n        }\n    }\n\n    @Test\n    public void throwsExceptionIfFileNotFound(){\n        try {\n            Network n = new Network("Obscurename");\n            assert false;\n        }\n        catch (Exception ex){ assert ex instanceof IOException; }\n    }\n}\n', 'NoNameException.java': 'package exceptions;\n\n/**\n * Exception thrown when a {@link stops.Stop} is created with a null or empty name.\n */\npublic class NoNameException extends RuntimeException {\n}\n', 'OverCapacityException.java': 'package exceptions;\n\nimport passengers.Passenger;\nimport vehicles.PublicTransport;\n\n/**\n * Exception thrown when a {@link Passenger} is added to a\n * {@link PublicTransport} which has reached capacity.\n *\n * (i.e. {@link PublicTransport#passengerCount()} >= {@link PublicTransport#getCapacity()})\n */\npublic class OverCapacityException extends TransportException {\n}\n', 'Passenger.java': 'package passengers;\n\nimport stops.Stop;\n\n/**\n * A base passenger in the transport network.\n */\npublic class Passenger {\n    // name of the passenger\n    private String name;\n\n    // intended destination of the passenger\n    private Stop destination;\n\n    /**\n     * Construct a new base passenger with the given name, and without a destination.\n     *\n     * <p>If the given name is null, an empty string should be stored instead.\n     *\n     * <p>If the given name contains any newline characters (\'\\n\') or carriage returns\n     * (\'\\r\'), they should be removed from the string before it is stored.\n     *\n     * @param name The name of the passenger.\n     */\n    public Passenger(String name) {\n        this.name = name == null ? "" : name.replace("\\n","")\n                .replace("\\r", "");\n        this.destination = null;\n    }\n\n    /**\n     * Construct a new base passenger with the given name and destination.\n     *\n     * <p> Should meet the specification of {@link Passenger#Passenger(String)},\n     * as well as storing the given destination stop.\n     *\n     * @param name The name of the passenger.\n     * @param destination The destination of the passenger.\n     */\n    public Passenger(String name, Stop destination) {\n        this(name);\n        this.destination = destination;\n    }\n\n    /**\n     * Returns the name of the passenger.\n     *\n     * @return The name of the passenger.\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Sets the destination of the passenger.\n     *\n     * <p>A value of null for the given stop simply indicates that the passenger\n     * has no destination.\n     *\n     * @param destination The intended destination of the passenger, or null if\n     *                    the passenger has no destination.\n     */\n    public void setDestination(Stop destination) {\n        this.destination = destination;\n    }\n\n    /**\n     * Gets the destination of the passenger.\n     *\n     * @return The intended destination of the passenger, or null if the passenger\n     * has no destination.\n     */\n    public Stop getDestination() {\n        return destination;\n    }\n\n    /**\n     * Creates a string representation of the passenger in the format:\n     *\n     * <p>\'Passenger named {name}\'\n     *\n     * <p>without surrounding quotes and with {name} replaced by the name of the\n     * passenger instance. For example:\n     *\n     * <p>Passenger named Agatha\n     *\n     * <p>If the passenger\'s name is empty, the method should instead return the\n     * following:\n     *\n     * <p>Anonymous passenger\n     *\n     * @return A string representation of the passenger.\n     */\n    @Override\n    public String toString() {\n        return name.isEmpty() ? "Anonymous passenger" : "Passenger named " + name;\n    }\n}\n', 'PublicTransport.java': 'package vehicles;\n\nimport exceptions.EmptyRouteException;\nimport exceptions.OverCapacityException;\nimport exceptions.TransportException;\nimport exceptions.TransportFormatException;\nimport passengers.Passenger;\nimport routes.Route;\nimport stops.Stop;\nimport utilities.Writeable;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * A base public transport vehicle in the transportation network.\n */\npublic abstract class PublicTransport implements Writeable {\n    // the passengers currently on board the vehicle\n    private List<Passenger> passengers;\n\n    // the place the vehicle is currently stopped\n    private Stop currentLocation;\n\n    // the maximum passengers allowed on board the vehicle\n    private int capacity;\n\n    // the vehicle\'s identifier\n    private int id;\n\n    // the route the vehicle follows\n    private Route route;\n\n    /**\n     * Creates a new public transport vehicle with the given id, capacity, and\n     * route.\n     *\n     * <p>The vehicle should initially have no passengers on board, and should be placed\n     * at the beginning of the given route (given by {@link Route#getStartStop()}).\n     * If the route is empty, the current location should be stored as null.\n     *\n     * <p> If the given capacity is negative, 0 should be stored as the capacity\n     * instead (meaning no passengers will be allowed on board this vehicle).\n     *\n     * @param id The identifying number of the vehicle.\n     * @param capacity The maximum number of passengers allowed on board.\n     * @param route The route the vehicle follows. Note that the given route should\n     *              never be null (@require route != null), and thus will not be\n     *              tested with a null value.\n     */\n    public PublicTransport(int id, int capacity, Route route) {\n        this.passengers = new ArrayList<>();\n        this.capacity = capacity < 0 ? 0 : capacity;\n        this.id = id;\n        this.route = route;\n        try {\n            this.currentLocation = route.getStartStop();\n        } catch (EmptyRouteException e) {\n            this.currentLocation = null;\n        }\n    }\n\n    /**\n     * Returns the route this vehicle is on.\n     *\n     * @return The route this vehicle is on.\n     */\n    public Route getRoute() {\n        return route;\n    }\n\n    /**\n     * Returns the id of this vehicle.\n     *\n     * @return The id of this vehicle.\n     */\n    public int getId() {\n        return id;\n    }\n\n    /**\n     * Returns the current location of this vehicle.\n     *\n     * @return The stop this vehicle is currently located at, or null if it is not\n     *         currently located at a stop.\n     */\n    public Stop getCurrentStop() {\n        return currentLocation;\n    }\n\n    /**\n     * Returns the number of passengers currently on board this vehicle.\n     *\n     * @return The number of passengers in the vehicle.\n     */\n    public int passengerCount() {\n        return passengers.size();\n    }\n\n    /**\n     * Returns the maximum number of passengers allowed on this vehicle.\n     *\n     * @return The maximum capacity of the vehicle.\n     */\n    public int getCapacity() {\n        return capacity;\n    }\n\n    /**\n     * Returns the type of this vehicle, as determined by the type of the route it\n     * is on (i.e. The type returned by {@link Route#getType()}).\n     *\n     * @return The type of this vehicle.\n     */\n    public String getType() {\n        return route.getType();\n    }\n\n    /**\n     * Returns the passengers currently on-board this vehicle.\n     *\n     * <p>No specific order is required for the passenger objects in the returned\n     * list.\n     *\n     * <p>Modifying the returned list should not result in changes to the internal\n     * state of the class.\n     *\n     * @return The passengers currently on the public transport vehicle.\n     */\n    public List<Passenger> getPassengers() {\n        return new ArrayList<>(passengers);\n    }\n\n    /**\n     * Adds the given passenger to this vehicle.\n     *\n     * <p>If the passenger is null, the method should return without adding it\n     * to the vehicle.\n     *\n     * <p>If the vehicle is already at (or over) capacity, an exception should\n     * be thrown and the passenger should not be added to the vehicle.\n     *\n     * @param passenger The passenger boarding the vehicle.\n     * @throws OverCapacityException If the vehicle is already at (or over) capacity.\n     */\n    public void addPassenger(Passenger passenger) throws OverCapacityException {\n        if (passenger == null) {\n            return;\n        }\n\n        if (passengers.size() >= capacity) {\n            throw new OverCapacityException();\n        }\n        passengers.add(passenger);\n    }\n\n    /**\n     * Removes the given passenger from the vehicle.\n     *\n     * <p>If the passenger is null, or is not on board the vehicle, the method should\n     * return false, and should not have any effect on the passengers currently\n     * on the vehicle.\n     *\n     * @param passenger The passenger disembarking the vehicle.\n     * @return True if the passenger was successfully removed, false otherwise (including\n     *         the case where the given passenger was not on board the vehicle to\n     *         begin with).\n     */\n    public boolean removePassenger(Passenger passenger) {\n        return passengers.remove(passenger);\n    }\n\n    /**\n     * Empties the vehicle of all its current passengers, and returns all the passengers\n     * who were removed.\n     *\n     * <p>No specific order is required for the passenger objects in the returned\n     * list.\n     *\n     * <p>If there are no passengers currently on the vehicle, the method just\n     * returns an empty list.\n     *\n     * <p>Modifying the returned list should not result in changes to the internal\n     * state of the class.\n     *\n     * @return The passengers who used to be on the vehicle.\n     */\n    public List<Passenger> unload() {\n        List<Passenger> leaving = passengers;\n        passengers = new ArrayList<>();\n        return leaving;\n    }\n\n    /**\n     * Updates the current location of the vehicle to be the given stop.\n     *\n     * <p>If the given stop is null, or is not on this public transport\'s route\n     * the current location should remain unchanged.\n     *\n     * @param stop The stop the vehicle has travelled to.\n     */\n    public void travelTo(Stop stop) {\n        if (!route.getStopsOnRoute().contains(stop)) {\n            return;\n        }\n\n\n\n        currentLocation = stop == null ? currentLocation : stop;\n    }\n\n    /**\n     * Creates a string representation of a public transport vehicle in the format:\n     *\n     * <p>\'{type} number {id} ({capacity}) on route {route}\'\n     *\n     * <p>without the surrounding quotes, and where {type} is replaced by the type of\n     * the vehicle, {id} is replaced by the id of the vehicle, {capacity} is replaced\n     * by the maximum capacity of the vehicle, and {route} is replaced by the route\n     * number of the route the vehicle is on. For example:\n     *\n     * <p>bus number 1 (30) on route 1\n     *\n     * @return A string representation of the vehicle.\n     */\n    @Override\n    public String toString() {\n        return getType() + " number " + id + " (" + capacity + ") on route " + route.getRouteNumber();\n    }\n\n    /**\n     * Encodes this vehicle as a string in the format:\n     * \'{type},{id},{capacity},{route}\'\n     *\n     * without the surrounding quotes, and where {type} is replaced by the type of the vehicle,\n     * {id} is replaced by the id of the vehicle,\n     * {capacity} is replaced by the maximum capacity of the vehicle,\n     * and {route} is replaced by the route number of the route the vehicle is on.\n     * For example:\n     *\n     * bus,1,30,1\n     * @return String representation of this vehicle\n     */\n    @Override\n    public String encode() { return getType() + \',\' + id + \',\' + capacity + \',\' + route.getRouteNumber(); }\n\n    /**\n     * Creates a new public transport object based on the given string representation.\n     * The format of the given string should match that returned by the encode() method, with one modification:\n     *\n     * \'{type},{id},{capacity},{route},{extra}\'\n     *\n     * where all parts of the string are as defined in encode(), except for {extra}, which should be replaced with a\n     * different part depending on the type of vehicle being decoded (as given by {type}).\n     *\n     * If {type} is bus, then {extra} should be the registration number of the bus.\n     * If {type} is train, then {extra} should be the carriage count of the train.\n     * If {type} is ferry, then {extra} should be the type of the ferry.\n     *\n     * The decoded vehicle will be added to the Route indicated by {route}. If there are multiple routes in the\n     * existingRoutes list which have the same number, then the first route in the list with a matching number will be used.\n     *\n     * @param transportString String to be parsed\n     * @param existingRoutes Routes already existing in the network\n     * @return Decoded vehicle\n     * @throws TransportFormatException A transport type that is not one of "bus", "train", or "ferry".\n     * @throws TransportFormatException One of the id, capacity, or route number is not an integer value.\n     * @throws TransportFormatException The route number given in the string does not match one of the given existingRoutes.\n     * @throws TransportFormatException The type of the route referenced in the given string does not match the type\n     * given in the transportString (e.g. a Bus referencing a TrainRoute)\n     * @throws TransportFormatException A vehicle of type train whose {extra} part (i.e. carriage count) is not an int value.\n     * @throws TransportFormatException An error (i.e. EmptyRouteException or IncompatibleTypeException is encountered\n     * whilst adding the vehicle to its route\n     * @throws TransportFormatException Any extra delimiters (,) being encountered whilst parsing.\n     * @throws TransportFormatException Any of the parts of the string being missing.\n     */\n    public static PublicTransport decode(String transportString,\n                                         List<Route> existingRoutes) throws TransportFormatException{\n        //Purify the input\n        if(transportString == null || transportString.isEmpty() || existingRoutes == null)\n            throw new TransportFormatException();\n        //Only letters,spaces,commas and numbers allowed\n        if(!transportString.matches("[a-zA-Z0-9 ,]+"))\n            throw new TransportFormatException();\n        String[] parts = transportString.split(",");\n        //We should have exactly 5 parts, otherwise we have missing parts or extra delimiters\n        if(parts.length != 5)\n            throw new TransportFormatException();\n        ArrayList<String> possibleTypes = new ArrayList<>(Arrays.asList("bus","train","ferry"));\n        if(!possibleTypes.contains(parts[0]))\n            throw new TransportFormatException();\n        String transportType = parts[0];\n        //Parse the string for id,capacity,route number and optionally carriageCount, if any of those are wrong\n        //string is no good, so we can use the same try catch block\n        int transportId;\n        int capacity;\n        int routeNumber;\n        int carriageCount = -1;\n        try{\n            transportId = Integer.parseInt(parts[1].trim());\n            capacity = Integer.parseInt(parts[2].trim());\n            routeNumber = Integer.parseInt(parts[3].trim());\n            if(transportType.equals("train"))\n                carriageCount = Integer.parseInt(parts[4].trim());\n        }\n        catch (Exception ex)\n        {\n            throw new TransportFormatException();\n        }\n        Route decodedRoute = null;\n        //Look for the existence of a given route number and match the type\n        for (Route r: existingRoutes) {\n            if(r.getRouteNumber() == routeNumber){\n                decodedRoute = r;\n                if(!decodedRoute.getType().equals(transportType))\n                    throw new TransportFormatException();\n            }\n        }\n        if(decodedRoute == null)\n            throw new TransportFormatException();\n        //Look for extra string, if it is magically empty - throw\n        if(parts[4].isEmpty())\n            throw new TransportFormatException();\n        PublicTransport transportToReturn;\n        switch (transportType)\n        {\n            case "bus":\n                transportToReturn = new Bus(transportId,capacity,decodedRoute,parts[4]);\n                break;\n            case "train":\n                transportToReturn = new Train(transportId,capacity,decodedRoute,carriageCount);\n                break;\n            case "ferry":\n                transportToReturn = new Ferry(transportId,capacity,decodedRoute,parts[4]);\n                break;\n                default:\n                    throw new TransportFormatException();\n        }\n        try{\n\n\n            decodedRoute.addTransport(transportToReturn);\n        }\n        //Use base class, we don\'t really care what exactly happened\n        catch (TransportException ex)\n        {\n            throw new TransportFormatException();\n        }\n        return transportToReturn;\n    }\n}\n', 'Route.java': 'package routes;\n\nimport exceptions.EmptyRouteException;\nimport exceptions.IncompatibleTypeException;\nimport exceptions.TransportFormatException;\nimport stops.Stop;\nimport utilities.Writeable;\nimport vehicles.PublicTransport;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedHashSet;\nimport java.util.List;\n\n/**\n * Represents a route in the transportation network.\n *\n * <p>A route is essentially a collection of stops which public transport vehicles\n * can follow.\n */\npublic abstract class Route implements Writeable {\n    // the name of the route\n    private String name;\n\n    // the number of the route\n    private int routeNumber;\n\n    // tracks where vehicles are currently located on the route\n    private List<PublicTransport> vehicles;\n\n    // the stops which make up the route\n    private List<Stop> route;\n\n    /**\n     * Creates a new Route with the given name and number.\n     *\n     * <p>The route should initially have no stops or vehicles on it.\n     *\n     * <p>If the given name contains any newline characters (\'\\n\') or carriage returns\n     * (\'\\r\'), they should be removed from the string before it is stored.\n     *\n     * <p>If the given name is null, an empty string should be stored in its place.\n     *\n     * @param name The name of the route.\n     * @param routeNumber The route number of the route.\n     */\n    public Route(String name, int routeNumber) {\n        this.name = name == null ? "" : name.replace("\\n", "")\n                .replace("\\r", "");\n        this.routeNumber = routeNumber;\n        this.vehicles = new ArrayList<>();\n        this.route = new ArrayList<>();\n    }\n\n    /**\n     * Returns the name of the route.\n     *\n     * @return The route name.\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the number of the route.\n     *\n     * @return The route number.\n     */\n    public int getRouteNumber() {\n        return routeNumber;\n    }\n\n    /**\n     * Returns the stops which comprise this route.\n     *\n     * <p>The order of the stops in the returned list should be the same as the\n     * order in which the stops were added to the route.\n     *\n     * <p>Modifying the returned list should not result in changes to the internal\n     * state of the class.\n     *\n     * @return The stops making up the route.\n     */\n    public List<Stop> getStopsOnRoute() {\n        return new ArrayList<>(route);\n    }\n\n    /**\n     * Returns the first stop of the route (i.e. the first stop to be added to the\n     * route).\n     *\n     * @return The start stop of the route.\n     * @throws EmptyRouteException If there are no stops currently on the route\n     */\n    public Stop getStartStop() throws EmptyRouteException {\n        if (route.isEmpty()) {\n            throw new EmptyRouteException();\n        }\n\n        return route.get(0);\n    }\n\n    /**\n     * Adds a stop to the route.\n     *\n     * <p>If the given stop is null, it should not be added to the route.\n     *\n     * <p>If this is the first stop to be added to the route, the given stop should\n     * be recorded as the starting stop of the route. Otherwise, the given stop\n     * should be recorded as a neighbouring stop of the previous stop on the route\n     * (and vice versa) using the {@link Stop#addNeighbouringStop(Stop)} method.\n     *\n     * <p>This route should also be added as a route of the given stop (if the given\n     * stop is not null) using the {@link Stop#addRoute(Route)} method.\n     *\n     * @param stop The stop to be added to this route.\n     */\n    public void addStop(Stop stop) {\n        if (stop == null) {\n            return;\n        }\n\n        stop.addRoute(this);\n        route.add(stop);\n\n        // return if this was the first stop\n        if (route.size() == 1) {\n            return;\n        }\n\n        Stop previous = route.get(route.size() - 2);\n        previous.addNeighbouringStop(stop);\n        stop.addNeighbouringStop(previous);\n    }\n\n    /**\n     * Returns the public transport vehicles currently on this route.\n     *\n     * <p>No specific order is required for the public transport objects in the\n     * returned list.\n     *\n     * <p>Modifying the returned list should not result in changes to the internal\n     * state of the class.\n     *\n     * @return The vehicles currently on the route.\n     */\n    public List<PublicTransport> getTransports() {\n        return new ArrayList<>(this.vehicles);\n    }\n\n    /**\n     * Adds a vehicle to this route.\n     *\n     * <p>If the given transport is null, it should not be added to the route.\n     *\n     * <p>The method should check for the transport being null first, then for an\n     * empty route, and then for incompatible types (in that order).</p>\n     *\n     * @param transport The vehicle to be added to the route.\n     * @throws EmptyRouteException If there are not yet any stops on the route.\n     * @throws IncompatibleTypeException If the given vehicle is of the incorrect\n     *      type for this route. This depends on the type of the route, i.e. a\n     *      BusRoute can only accept Bus instances.\n     */\n    public void addTransport(PublicTransport transport)\n            throws EmptyRouteException, IncompatibleTypeException {\n        if (transport == null) {\n            return;\n        }\n\n        if (route.isEmpty()) {\n            throw new EmptyRouteException();\n        }\n\n        if (!getType().equals(transport.getType())) {\n            throw new IncompatibleTypeException();\n        }\n\n        vehicles.add(transport);\n    }\n\n    /**\n     * Compares this stop with another object for equality.\n     *\n     * Two routes are equal if their names and route numbers are equal.\n     *\n     * {@inheritDoc}\n     *\n     * @param other The other object to compare for equality.\n     * @return True if the objects are equal (as defined above), false otherwise\n     *         (including if other is null or not an instance of the {@link Route}\n     *         class.\n     */\n    @Override\n    public boolean equals(Object other) {\n        if (!(other instanceof Route)) {\n            return false;\n        }\n        Route otherRoute = (Route) other;\n        return name.equals(((Route) other).getName())\n                && routeNumber == otherRoute.getRouteNumber();\n    }\n\n    @Override\n    public int hashCode() {\n        return routeNumber;\n    }\n\n    /**\n     * Returns the type of this route.\n     *\n     * @return The type of the route (see subclasses)\n     */\n    public abstract String getType();\n\n    /**\n     * Creates a string representation of a route in the format:\n     *\n     * <p>\'{type},{name},{number}:{stop0}|{stop1}|...|{stopN}\'\n     *\n     * <p>without the surrounding quotes, and where {type} is replaced by the type\n     * of the route, {name} is replaced by the name of the route, {number} is replaced\n     * by the route number, and {stop0}|{stop1}|...|{stopN} is replaced by a list of\n     * the names of the stops stops making up the route. For example:\n     *\n     * <p>bus,red,1:UQ Lakes|City|Valley\n     *\n     * @return A string representation of the route.\n     */\n    @Override\n    public String toString() {\n        StringBuilder builder = new StringBuilder();\n\n        builder.append(getType()).append(",");\n        builder.append(name).append(",").append(routeNumber);\n        builder.append(":");\n\n        for (Stop stop : route) {\n\n\n            builder.append(stop.getName()).append("|");\n        }\n\n        if (!route.isEmpty()) {\n            builder.deleteCharAt(builder.length() - 1);\n        }\n\n        return builder.toString();\n    }\n\n    /**\n     * Encodes this route as a string in the same format as specified in toString().\n     * @return This route encoded as a string.\n     */\n    @Override\n    public String encode() {\n        return toString();\n    }\n\n    /**\n     * Creates a new route object based on the given string representation.\n     * The format of the string should match that returned by the encode() method.\n     *\n     *  If there are multiple stops in the existingStops list which have the same name, then the first stop in the list\n     *  with a matching name will be used. This still applies if there are multiple stops in the routeString with the\n     *  same name (i.e. they will both use the first stop in the list with a matching name).\n     * @param routeString String to be decoded\n     * @param existingStops List of stops currently present in network\n     * @return Route, composed from the given string with stops attached\n     * @throws TransportFormatException A route type that is not one of "bus", "train", or "ferry".\n     * @throws TransportFormatException The route number is not an integer value.\n     * @throws TransportFormatException The stop name given in the string does not match one of the given existingStops.\n     * @throws TransportFormatException Any extra delimiters (, : |) being encountered whilst parsing.\n     * @throws TransportFormatException Any of the parts of the string being missing. This includes empty strings\n     * as stop names in the routeString (e.g. \'bus,red,1:||\'). A routeString with no stops (e.g. \'bus,red,1:\')\n     * is, however, valid. A routeString with an empty name is also valid (as this is allowed by the Route constructor).\n     */\n    public static Route decode(String routeString,\n                               List<Stop> existingStops)\n            throws TransportFormatException{\n        //Verifying input\n        if(routeString == null || routeString.isEmpty() || existingStops == null)\n            throw new TransportFormatException();\n        String[] parts = routeString.split(",");\n        //We only append 2 commas so we end up with 3 parts\n        if(parts.length != 3)\n            throw new TransportFormatException();\n        //Only 3 types supported so far\n        ArrayList<String> possibleTypes = new ArrayList<>(Arrays.asList("bus","train","ferry"));\n        if(!possibleTypes.contains(parts[0]))\n            throw new TransportFormatException();\n        String routeType = parts[0];\n        //Only letters,spaces and numbers are allowed in name, empty name is valid\n        if(!parts[1].isEmpty() && !parts[1].matches("[a-zA-Z0-9 ]+"))\n            throw new TransportFormatException();\n        String routeName = parts[1];\n        String[] split = parts[2].split(":");\n        //If we have no stops  - second part of the split will be empty\n        if(split.length > 2 || split.length == 0)\n\n\n            throw new TransportFormatException();\n        int routeNumber;\n        try {\n            routeNumber = Integer.parseInt(split[0].trim());\n        }\n        catch (NumberFormatException nfe)\n        {\n            throw new TransportFormatException();\n        }\n        String stopsString = "";\n        if(split.length == 2)\n             stopsString = split[1].trim();\n        Route toReturn;\n        switch (routeType)\n        {\n            case "bus":\n                toReturn = new BusRoute(routeName,routeNumber);\n                break;\n            case "train":\n                toReturn = new TrainRoute(routeName,routeNumber);\n                break;\n            case "ferry":\n                toReturn = new FerryRoute(routeName,routeNumber);\n                break;\n            default: throw new TransportFormatException();\n        }\n        //No stops to parse, so just return corresponding route\n        if(!stopsString.isEmpty()) {\n            if (!stopsString.matches("[a-zA-Z0-9 |]+"))\n                throw new TransportFormatException();\n            //Split it and check that there are no empty\n            String[] stopSplits = stopsString.split("[|]");\n            int delimiterCounter = 0;\n            for (char c:stopsString.toCharArray()) {\n                if(c == \'|\') delimiterCounter++;\n            }\n            //There should be as many stops as amount of delimiters - 1, so if it does not match we have extra\n            //delimiters or empty stop names\n            if(stopSplits.length - delimiterCounter != 1)\n                throw new TransportFormatException();\n            //Order is important and we don\'t need repetitions so LinkedSet is the answer\n            LinkedHashSet<Stop> stops = new LinkedHashSet<>();\n            for (String str : stopSplits\n            ) {\n                if (str.isEmpty()) throw new TransportFormatException();\n                //Check that stop is actually contained in the existing list\n                boolean flag = false;\n                for (Stop stop : existingStops\n                ) {\n                    if (stop.getName().equals(str)) {\n                        stops.add(stop);\n                        flag = true;\n                        break;\n                    }\n                }\n                if (!flag)\n                    throw new TransportFormatException();\n            }\n            for (Stop s: stops\n                 ) {\n                toReturn.addStop(s);\n            }\n        }\n            return toReturn;\n    }\n}\n', 'Stop.java': 'package stops;\n\nimport exceptions.NoNameException;\nimport exceptions.TransportFormatException;\nimport passengers.Passenger;\nimport routes.Route;\nimport utilities.Writeable;\nimport vehicles.PublicTransport;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Represents a stop in the transportation network.\n *\n * <p>Stops are where public transport vehicles collect and drop off passengers,\n * and are located along one or more routes.\n */\npublic class Stop implements Writeable {\n    // the name of the stop\n    private String name;\n\n    // the passengers currently waiting at the stop\n    private List<Passenger> passengers;\n\n    // the routes which this stop is located on\n    private List<Route> routes;\n\n    // the vehicles currently at this stop\n    private Set<PublicTransport> atStop;\n\n    // the stops directly adjacent to this stop along routes\n    private List<Stop> neighbours;\n\n    // the x and y coordinates of this stop\n    private int xCoordinate;\n    private int yCoordinate;\n\n\n    /**\n     * Creates a new Stop object with the given name and coordinates.\n     *\n     * <p>A stop should be created with no passengers, routes, or vehicles.\n     *\n     * <p>If the given name contains any newline characters (\'\\n\') or carriage returns\n     * (\'\\r\'), they should be removed from the string before it is stored.\n     *\n     * @param name The name of the stop being created.\n     * @param x The x coordinate of the stop being created.\n     * @param y The y coordinate of the stop being created.\n     * @throws NoNameException If the given name is null or empty.\n     */\n    public Stop(String name, int x, int y) {\n        if (name == null || name.isEmpty()) {\n            throw new NoNameException();\n        }\n        this.name = name.replace("\\n", "")\n                .replace("\\r", "");\n        this.xCoordinate = x;\n        this.yCoordinate = y;\n\n        this.neighbours = new ArrayList<>();\n        this.passengers = new ArrayList<>();\n        this.routes = new ArrayList<>();\n        this.atStop = new HashSet<>();\n    }\n\n    /**\n     * Returns the name of this stop.\n     *\n     * @return The name of the stop.\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the x-coordinate of this stop.\n     *\n     * @return The x-coordinate of the stop.\n     */\n    public int getX() {\n        return xCoordinate;\n    }\n\n    /**\n     * Returns the y-coordinate of this stop.\n     *\n     * @return The y-coordinate of the stop.\n     */\n    public int getY() {\n        return yCoordinate;\n    }\n\n    /**\n     * Records that this stop is part of the given route.\n     *\n     * If the given route is null, it should not be added to the stop.\n     *\n     * @param route The route to be added.\n     */\n    public void addRoute(Route route) {\n        if (route == null) {\n            return;\n        }\n        routes.add(route);\n    }\n\n    /**\n     * Returns the routes associated with this stop.\n     *\n     * <p>No specific order is required for the route objects in the returned list.\n     *\n     * <p>Modifying the returned list should not result in changes to the internal\n     * state of the class.\n     *\n     * @return The routes which go past the stop.\n     */\n    public List<Route> getRoutes() {\n        return new ArrayList<>(routes);\n    }\n\n    /**\n     * Records the given stop as being a neighbour of this stop.\n     *\n     * <p>If the given stop is null, or if this stop is already recorded as a neighbour,\n     * it should not be added as a neighbour, and the method should return early.\n     *\n     * @param neighbour The stop to add as a neighbour.\n     */\n    public void addNeighbouringStop(Stop neighbour) {\n        if (neighbour == null || neighbours.contains(neighbour)) {\n            return;\n        }\n        neighbours.add(neighbour);\n    }\n\n    /**\n     * Returns all of the stops adjacent to this one on any routes.\n     *\n     * <p>No specific order is required for the stop objects in the returned list.\n     *\n     * <p>Modifying the returned list should not result in changes to the internal\n     * state of the class.\n     *\n     * @return The neighbours of this stop.\n     */\n    public List<Stop> getNeighbours() {\n        return new ArrayList<>(neighbours);\n    }\n\n    /**\n     * Places a passenger at this stop.\n     *\n     * <p>If the given passenger is null, it should not be added to the stop.\n     *\n     * @param passenger The passenger to add to the stop.\n     */\n    public void addPassenger(Passenger passenger) {\n        if (passenger == null) {\n            return;\n        }\n        this.passengers.add(passenger);\n    }\n\n    /**\n     * Returns the passengers currently at this stop.\n     *\n     * <p>The order of the passengers in the returned list should be the same as the\n     * order in which the passengers were added to the stop.\n     *\n     * <p>Modifying the returned list should not result in changes to the internal\n     * state of the class.\n     *\n     * @return The passengers currently waiting at the stop.\n     */\n    public List<Passenger> getWaitingPassengers() {\n        return new ArrayList<>(passengers);\n    }\n\n    /**\n     * Checks whether the given public transport vehicle is at this stop or not.\n     *\n     * @param transport The transport vehicle to check for.\n     * @return True if the vehicle is at this stop, false otherwise.\n     */\n    public boolean isAtStop(PublicTransport transport) {\n        return atStop.contains(transport);\n    }\n\n    /**\n     * Returns the vehicles currently at this stop.\n     *\n     * <p>No specific order is required for the public transport objects in the\n     * returned list.\n     *\n     * <p>Modifying the returned list should not result in changes to the internal\n     * state of the class.\n     *\n     * @return The vehicles currently at the stop.\n     */\n    public List<PublicTransport> getVehicles() {\n        return new ArrayList<>(atStop);\n    }\n\n    /**\n     * Records a public transport vehicle arriving at this stop. There is no limit\n     * on the number of vehicles that can be at a stop simultaneously.\n     *\n     * <p>If the given vehicle is already at this stop, or if the vehicle is null,\n     * do nothing.\n     *\n     * <p>Otherwise, unload all of the passengers on the arriving vehicle (using\n     * {@link PublicTransport#unload()}), and place them at this stop, as well as\n     * recording the vehicle itself at this stop.\n     *\n     * <p>This method does not need to check whether this stop is on the given transport\'s\n     * route, or whether the transport\'s route is a route of this stop, and should\n     * also not update the location of the transport.\n     *\n     * @param transport The public transport vehicle arriving at this stop.\n     */\n    public void transportArrive(PublicTransport transport) {\n        if (transport == null || isAtStop(transport)) {\n            return;\n        }\n\n        List<Passenger> arriving = transport.unload();\n        for (Passenger passenger : arriving) {\n            addPassenger(passenger);\n        }\n\n        atStop.add(transport);\n    }\n\n    /**\n     * Records a public transport vehicle departing this stop and travelling to a\n     * new stop.\n     *\n     * <p>This method should also update the vehicle\'s location to be the next stop\n     * (using {@link PublicTransport#travelTo(Stop)}).\n     *\n     * <p>If the given vehicle is not at this stop, or if the vehicle is null, or\n     * if the next stop is null, do nothing.\n     *\n     * @param transport The transport currently leaving this stop.\n     * @param nextStop The stop which the transport is travelling to.\n     */\n    public void transportDepart(PublicTransport transport, Stop nextStop) {\n        if (!isAtStop(transport) || nextStop == null) {\n            return;\n        }\n        transport.travelTo(nextStop);\n        atStop.remove(transport);\n    }\n\n    /**\n     * Returns the Manhattan distance between this stop and the given other stop.\n     *\n     * <p>Manhattan distance between two points, for example (x1, y1) and (x2, y2),\n     * is calculated using the following formula:<br>\n     * abs(x1 - x2) + abs(y1 - y2)<br>\n     * where abs is a method that calculates the absolute value of a number.\n     *\n     * @param stop The stop to calculate the Manhattan distance to.\n     * @return The Manhattan distance between this stop and the given stop (or -1\n     *         if the given stop is null)\n     */\n    public int distanceTo(Stop stop) {\n        if (stop == null) {\n            return -1;\n        }\n        return Math.abs(getX() - stop.getX()) + Math.abs(getY() - stop.getY());\n    }\n\n    /**\n     * Compares this stop to the other object for equality.\n     *\n     * <p>Two stops are considered equal if they have the same name, x-coordinate,\n     * y-coordinate, and routes. Routes may be in any order, as long as all of this\n     * stop\'s routes are also associated with the other stop, and vice versa. Duplicates\n     * of routes do not need to be considered in determining equality (that is,\n     * if this stop has routes R1 and R2, and other has routes R1, R2, and R1 again,\n     * their routes can still be considered equal, ignoring duplicates).\n     *\n     * {@inheritDoc}\n     *\n     * @param other the other object to compare for equality.\n     * @return True if the objects are equal (as defined above), false otherwise\n     *         (including if other is null or not an instance of the {@link Stop}\n     *         class.\n     */\n    @Override\n    public boolean equals(Object other) {\n        if (!(other instanceof Stop)) {\n            return false;\n        }\n        Stop otherStop = (Stop) other;\n        return this.name.equals(otherStop.getName())\n                && this.xCoordinate == otherStop.getX()\n                && this.yCoordinate == otherStop.getY()\n                && new HashSet<>(this.routes).equals(new HashSet<>(otherStop.getRoutes()));\n    }\n\n    @Override\n    public int hashCode() {\n\n\n        return this.name.hashCode();\n    }\n\n    /**\n     * Creates a string representation of a stop in the format:\n     *\n     * <p>\'{name}:{x}:{y}\'\n     *\n     * <p>without the surrounding quotes, and where {name} is replaced by the name\n     * of the stop, {x} is replaced by the x-coordinate of the stop, and {y} is\n     * replaced by the y-coordinate of the stop.\n     *\n     * @return A string representation of the stop.\n     */\n    @Override\n    public String toString() {\n        return name + ":" + xCoordinate + ":" + yCoordinate;\n    }\n\n    /**\n     * Encodes this stop as a string in the same format as specified in toString().\n     * @return This stop encoded as a string\n     */\n    @Override\n    public String encode() {\n        return toString();\n    }\n\n    /**\n     * Creates a new stop object based on the given string representation.\n     * The format of the string should match that returned by the encode() method.\n     * @param stopString String to parse\n     * @return Decoded stop\n     * @throws TransportFormatException x or y coordinates that are not integer values\n     * @throws TransportFormatException Any extra delimiters (:) being encountered whilst parsing.\n     * @throws TransportFormatException Any of the parts of the string being missing. This includes a missing stop name\n     * (as this is defined as invalid according to the Stop constructor).\n     */\n    public  static Stop decode(String stopString) throws TransportFormatException {\n        //Purify input\n        if(stopString == null || stopString.isEmpty())\n            throw new TransportFormatException();\n        //Letters,spaces,numbers only\n        if(!stopString.matches("[a-zA-z:0-9 -]+"))\n            throw new TransportFormatException();\n        String[] parts = stopString.split(":");\n        //Only 2 delimiters so 3 parts, if any of them are empty - throw\n        if(parts.length != 3 || parts[0].trim().isEmpty() || parts[1].trim().isEmpty() || parts[2].trim().isEmpty())\n            throw new TransportFormatException();\n        String stopName = parts[0];\n        int x,y;\n        try {\n            x = Integer.parseInt(parts[1]);\n            y = Integer.parseInt(parts[2]);\n        }\n        catch (Exception ex)\n        {\n            throw new TransportFormatException();\n        }\n\n\n        return new Stop(stopName,x,y);\n    }\n}\n', 'Train.java': "package vehicles;\n\nimport routes.Route;\n\n/**\n * Represents a train in the transportation network.\n */\npublic class Train extends PublicTransport {\n    // the number of carriages the train has\n    private int carriageCount;\n\n    /**\n     * Creates a new Train object with the given id, capacity, route, and carriage\n     * count.\n     *\n     * <p>Should meet the specification of {@link PublicTransport#PublicTransport(int, int, Route)},\n     * as well as extending it to include the following:\n     *\n     * <p>If the given carriage count is less than or equal to zero, then 1 should be\n     * stored instead.\n     *\n     * @param id The identifying number of the train.\n     * @param capacity The maximum capacity of the train.\n     * @param route The route this train is on.\n     * @param carriageCount The number of carriages this train has.\n     */\n    public Train(int id, int capacity, Route route, int carriageCount) {\n        super(id, capacity, route);\n        this.carriageCount = Math.max(carriageCount, 1);\n    }\n\n    /**\n     * Returns the number of carriages this train has.\n     *\n     * @return The number of carriages the train has.\n     */\n    public int getCarriageCount() {\n        return carriageCount;\n    }\n\n    /**\n     * Encodes this train as a string in the same format as specified in PublicTransport.encode(),\n     * but with an additional component at the end, namely the carriage count.\n     * The encoded format should be as follows:\n     * '{type},{id},{capacity},{route},{carriages}'\n     *\n     * where {carriages} is replaced by the carriage count of this train, and all of the other components are the same\n     * as defined in the method being overridden.\n     * For example:\n     *\n     * train,3,100,3,5\n     * @return String representation of this Train\n     */\n    @Override\n    public String encode() {\n        return super.encode() + ',' + carriageCount;\n    }\n}\n", 'TrainRoute.java': 'package routes;\n\n/**\n * Represents a train route in the transportation network.\n */\npublic class TrainRoute extends Route {\n\n    /**\n     * Creates a new TrainRoute with the given name and number.\n     *\n     * <p>Should meet the specification of {@link Route#Route(String, int)}\n     *\n     * @param name The name of the route.\n     * @param routeNumber The route number of the route.\n     */\n    public TrainRoute(String name, int routeNumber) {\n        super(name, routeNumber);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @return "train"\n     */\n    @Override\n    public String getType() {\n        return "train";\n    }\n}\n', 'TransportException.java': 'package exceptions;\n\n/**\n * Base class for custom exceptions related to the transportation network.\n */\npublic class TransportException extends Exception {\n}\n', 'TransportFormatException.java': 'package exceptions;\n\n/**\n * Exception thrown when an encoded {@link network.Network} file is formatted incorrectly.\n */\npublic class TransportFormatException extends TransportException {\n}\n', 'Writeable.java': 'package utilities;\n\npublic interface Writeable {\n    /**\n     * Creates a string representation of the object for writing to a file.\n     * See implementing classes for specific implementation details.\n     * @return encoded string representation of an object\n     */\n    String encode();\n}\n'}]
      }
    },
    mounted() {
      $('table').tablesort();
      hljs.initHighlighting();
    }
  }
</script>
